\hypertarget{ab__memory_8h}{}\doxysection{ab\+\_\+memory.\+h File Reference}
\label{ab__memory_8h}\index{ab\_memory.h@{ab\_memory.h}}


Memory handling.  


{\ttfamily \#include \char`\"{}ab\+\_\+common.\+h\char`\"{}}\newline
Include dependency graph for ab\+\_\+memory.\+h\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=198pt]{d7/d5f/ab__memory_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d4/d8c/ab__memory_8h__dep__incl}
\end{center}
\end{figure}
\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{ab__memory_8h_ade8a4ab9a8d221e715d2a0733dd7128f}{mem\+\_\+\+Push\+Struct}}(Arena,  Type)~(Type$\ast$)mem\+\_\+\+Push\+Size\+\_\+(Arena, sizeof(Type))
\begin{DoxyCompactList}\small\item\em Get memory for the type or struct and return a pointer to the struct type. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{ab__memory_8h_ac2630c25d21e17ac2b347ff792cc5dbd}{mem\+\_\+\+Push\+Size}}(Arena,  Size)~mem\+\_\+\+Push\+Size\+\_\+(Arena, Size)
\begin{DoxyCompactList}\small\item\em Get memory of given size and return a pointer to memory. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{ab__memory_8h_ae626c2862d77390a2677b8819a09dd1e}{mem\+\_\+\+Push\+Array}}(Arena,  Count,  Type)~(Type$\ast$)mem\+\_\+\+Push\+Size\+\_\+(Arena, (Count)$\ast$sizeof(Type))
\begin{DoxyCompactList}\small\item\em Get memory for an array of types specified. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void $\ast$ \mbox{\hyperlink{ab__memory_8h_a65f300a0fc29f0fb26f7baa536eeef16}{mem\+\_\+\+Allocate\+Os\+Memory}} (void $\ast$Address, size\+\_\+t Size)
\begin{DoxyCompactList}\small\item\em Get memory from the OS. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{ab__memory_8h_aa817a02fd268b12b4ca75f15bfe6379c}{mem\+\_\+\+Deallocate\+Os\+Memory}} (void $\ast$Address, size\+\_\+t Size)
\begin{DoxyCompactList}\small\item\em Return memory to the OS. \end{DoxyCompactList}\item 
memory\+\_\+arena \mbox{\hyperlink{ab__memory_8h_a3dd694713416bf4f1fc1f0f1433440e0}{mem\+\_\+\+Init\+Memory}} (void $\ast$Start, size\+\_\+t Size)
\begin{DoxyCompactList}\small\item\em Initialize a memory\+\_\+arena. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{ab__memory_8h_a292359d189043396cc92d7c0de05fbec}{mem\+\_\+\+Reset\+Memory}} (memory\+\_\+arena $\ast$Memory)
\begin{DoxyCompactList}\small\item\em Delete everything in a {\ttfamily memory\+\_\+arena} and set the amount of memory used to 0. \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{ab__memory_8h_ada89f9419c002dbe71315a84e72444a1}{mem\+\_\+\+Get\+Memory\+Left}} (memory\+\_\+arena $\ast$Memory)
\begin{DoxyCompactList}\small\item\em Get the amount of memory left in an arena. \end{DoxyCompactList}\item 
temporary\+\_\+memory \mbox{\hyperlink{ab__memory_8h_a21e3b35f1c8dcdb00715eacb975da0b2}{mem\+\_\+\+Begin\+Temporary\+Memory}} (memory\+\_\+arena $\ast$Memory)
\begin{DoxyCompactList}\small\item\em Indicates the next section of memory is scratch, and will be cleared quickly. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{ab__memory_8h_a3d43731b8fe9679b5d342cf3c2c77e24}{mem\+\_\+\+End\+Temporary\+Memory}} (temporary\+\_\+memory Temp\+Mem)
\begin{DoxyCompactList}\small\item\em Ends the section of temporary memory. \end{DoxyCompactList}\item 
memory\+\_\+arena \mbox{\hyperlink{ab__memory_8h_aac527aab775805919b34095e3f0e0830}{mem\+\_\+\+Create\+Sub\+Arena}} (memory\+\_\+arena $\ast$Memory, size\+\_\+t Size)
\begin{DoxyCompactList}\small\item\em Create a {\ttfamily memory\+\_\+arena} inside an existing arena. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Memory handling. 

\begin{DoxyAuthor}{Author}
Amos Buchanan 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.\+0 
\end{DoxyVersion}
\begin{DoxyDate}{Date}
2020
\end{DoxyDate}
Getting and using blocks of memory, as oppossed to malloc/free anytime memory is desired. Works with Windows and Linux, with the OS specific implementation broken out into separate files. Generally, you grab a chunk of memory from the OS and use that chunk rather than constantly going out to the OS to get more when needed. To pull in for the appropriate OS, define either {\ttfamily \+\_\+\+L\+I\+N\+UX} or {\ttfamily \+\_\+\+W\+I\+N\+D\+O\+WS} in your build string or early in your project. (N\+O\+TE\+: Visual Studio adds a {\ttfamily \+\_\+\+W\+I\+N\+D\+O\+WS} define by default to C++ projects.

The use case for this library fits with the two methods of memory used in my projects\+:
\begin{DoxyItemize}
\item An initial block of memory that is initialized during setup, and not added to afterwards.
\item Scratch memory that is wiped out at the beginning of each control loop.
\end{DoxyItemize}

At this time, there isn\textquotesingle{}t really functionality for freeing and re-\/using memory. It\textquotesingle{}s generally not necessary in the use cases I current have, though if this changes that functionality will be added.

This is a single-\/file library. You may include it as a header just as any other. Add the following define to include the source {\itshape once} per project\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define MEMORY\_SRC}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}ab\_memory.h"{}}}
\end{DoxyCode}


It is not advised to use the arena structs directly; the functions should be used to manipulate the memory.

The code here is heavily influenced by Casey Muratori and \href{https://handmadehero.org/}{\texttt{ Handmade Hero}}.

Example Usage\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} MemorySize = \mbox{\hyperlink{ab__common_8h_a9e89c74d1fedd0a954107d7ab01481cc}{Kilobytes}}(150);}
\DoxyCodeLine{\textcolor{keywordtype}{void} *OsMemory = \mbox{\hyperlink{ab__memory_8h_a65f300a0fc29f0fb26f7baa536eeef16}{mem\_AllocateOsMemory}}(NULL, MemorySize);}
\DoxyCodeLine{memory\_arena MainMemory = \mbox{\hyperlink{ab__memory_8h_a3dd694713416bf4f1fc1f0f1433440e0}{mem\_InitMemory}}(OsMemory, MemorySize);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Begin initialization code here.}}
\DoxyCodeLine{my\_struct *MyStruct = \mbox{\hyperlink{ab__memory_8h_ade8a4ab9a8d221e715d2a0733dd7128f}{mem\_PushStruct}}(\&MainMemory, my\_struct);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const} \mbox{\hyperlink{ab__common_8h_afaa62991928fb9fb18ff0db62a040aba}{u32}} MyStructArrayLength = 50;}
\DoxyCodeLine{my\_struct *MyStructArray = \mbox{\hyperlink{ab__memory_8h_ae626c2862d77390a2677b8819a09dd1e}{mem\_PushArray}}(\&MainMemory, my\_struct, MyStructArrayLength);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} EmptyMemorySize = \mbox{\hyperlink{ab__common_8h_a9e89c74d1fedd0a954107d7ab01481cc}{Kilobytes}}(1);}
\DoxyCodeLine{\textcolor{keywordtype}{void} *EmptyMemory = \mbox{\hyperlink{ab__memory_8h_ac2630c25d21e17ac2b347ff792cc5dbd}{mem\_PushSize}}(\&MainMemory, EmptyMemorySize);}
\DoxyCodeLine{}
\DoxyCodeLine{memory\_arena VolatileMemory = \mbox{\hyperlink{ab__memory_8h_aac527aab775805919b34095e3f0e0830}{mem\_CreateSubArena}}(\&MainMemory, \mbox{\hyperlink{ab__common_8h_a9e89c74d1fedd0a954107d7ab01481cc}{Kilobytes}}(50));}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// End initialization.}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{while}(isRunning)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \mbox{\hyperlink{ab__memory_8h_a292359d189043396cc92d7c0de05fbec}{mem\_ResetMemory}}(\&VolatileMemory);}
\DoxyCodeLine{}
\DoxyCodeLine{    volatile\_struct *VolatileStruct = PushStruct(\&VolatileMemory, volatile\_struct);}
\DoxyCodeLine{    \textcolor{comment}{// Do Stuff Here.}}
\DoxyCodeLine{}
\DoxyCodeLine{    temporary\_memory ScratchMemory = \mbox{\hyperlink{ab__memory_8h_a21e3b35f1c8dcdb00715eacb975da0b2}{mem\_BeginTemporaryMemory}}(\&VolatileMemory);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Use the ScratchMemory for something here.}}
\DoxyCodeLine{}
\DoxyCodeLine{    \mbox{\hyperlink{ab__memory_8h_a3d43731b8fe9679b5d342cf3c2c77e24}{mem\_EndTemporaryMemory}}(ScratchMemory);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{ab__memory_8h_aa817a02fd268b12b4ca75f15bfe6379c}{mem\_DeallocateOsMemory}}(OsMemory, MemorySize);}
\end{DoxyCode}


See also\+:
\begin{DoxyItemize}
\item \mbox{\hyperlink{ab__memory__linux_8h}{ab\+\_\+memory\+\_\+linux.\+h}}
\item \mbox{\hyperlink{ab__memory__win32_8h}{ab\+\_\+memory\+\_\+win32.\+h}} 
\end{DoxyItemize}

\doxysubsection{Macro Definition Documentation}
\mbox{\Hypertarget{ab__memory_8h_ae626c2862d77390a2677b8819a09dd1e}\label{ab__memory_8h_ae626c2862d77390a2677b8819a09dd1e}} 
\index{ab\_memory.h@{ab\_memory.h}!mem\_PushArray@{mem\_PushArray}}
\index{mem\_PushArray@{mem\_PushArray}!ab\_memory.h@{ab\_memory.h}}
\doxysubsubsection{\texorpdfstring{mem\_PushArray}{mem\_PushArray}}
{\footnotesize\ttfamily \#define mem\+\_\+\+Push\+Array(\begin{DoxyParamCaption}\item[{}]{Arena,  }\item[{}]{Count,  }\item[{}]{Type }\end{DoxyParamCaption})~(Type$\ast$)mem\+\_\+\+Push\+Size\+\_\+(Arena, (Count)$\ast$sizeof(Type))}



Get memory for an array of types specified. 

This will clear the memory to 0.


\begin{DoxyParams}{Parameters}
{\em Arena} & A pointer to a {\ttfamily memory\+\_\+arena} to hold the array. \\
\hline
{\em Count} & Number of array elements to allocate. \\
\hline
{\em Type} & The type of array to allocate. Can be any type. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the first element in the array. 
\end{DoxyReturn}
\mbox{\Hypertarget{ab__memory_8h_ac2630c25d21e17ac2b347ff792cc5dbd}\label{ab__memory_8h_ac2630c25d21e17ac2b347ff792cc5dbd}} 
\index{ab\_memory.h@{ab\_memory.h}!mem\_PushSize@{mem\_PushSize}}
\index{mem\_PushSize@{mem\_PushSize}!ab\_memory.h@{ab\_memory.h}}
\doxysubsubsection{\texorpdfstring{mem\_PushSize}{mem\_PushSize}}
{\footnotesize\ttfamily \#define mem\+\_\+\+Push\+Size(\begin{DoxyParamCaption}\item[{}]{Arena,  }\item[{}]{Size }\end{DoxyParamCaption})~mem\+\_\+\+Push\+Size\+\_\+(Arena, Size)}



Get memory of given size and return a pointer to memory. 

This will clear the memory to 0.


\begin{DoxyParams}{Parameters}
{\em Arena} & A pointer to the memory\+\_\+arena. \\
\hline
{\em Size} & {\ttfamily size\+\_\+t} amount of memory to create. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\textquotesingle{}void$\ast$\`{} pointer to the start of the memory. 
\end{DoxyReturn}
\mbox{\Hypertarget{ab__memory_8h_ade8a4ab9a8d221e715d2a0733dd7128f}\label{ab__memory_8h_ade8a4ab9a8d221e715d2a0733dd7128f}} 
\index{ab\_memory.h@{ab\_memory.h}!mem\_PushStruct@{mem\_PushStruct}}
\index{mem\_PushStruct@{mem\_PushStruct}!ab\_memory.h@{ab\_memory.h}}
\doxysubsubsection{\texorpdfstring{mem\_PushStruct}{mem\_PushStruct}}
{\footnotesize\ttfamily \#define mem\+\_\+\+Push\+Struct(\begin{DoxyParamCaption}\item[{}]{Arena,  }\item[{}]{Type }\end{DoxyParamCaption})~(Type$\ast$)mem\+\_\+\+Push\+Size\+\_\+(Arena, sizeof(Type))}



Get memory for the type or struct and return a pointer to the struct type. 

This will clear the memory to 0.


\begin{DoxyParams}{Parameters}
{\em Arena} & A pointer to the memory arena. \\
\hline
{\em Type} & The struct type to allocate. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the struct type. 
\end{DoxyReturn}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{ab__memory_8h_a65f300a0fc29f0fb26f7baa536eeef16}\label{ab__memory_8h_a65f300a0fc29f0fb26f7baa536eeef16}} 
\index{ab\_memory.h@{ab\_memory.h}!mem\_AllocateOsMemory@{mem\_AllocateOsMemory}}
\index{mem\_AllocateOsMemory@{mem\_AllocateOsMemory}!ab\_memory.h@{ab\_memory.h}}
\doxysubsubsection{\texorpdfstring{mem\_AllocateOsMemory()}{mem\_AllocateOsMemory()}}
{\footnotesize\ttfamily void$\ast$ mem\+\_\+\+Allocate\+Os\+Memory (\begin{DoxyParamCaption}\item[{void $\ast$}]{Address,  }\item[{size\+\_\+t}]{Size }\end{DoxyParamCaption})}



Get memory from the OS. 


\begin{DoxyParams}{Parameters}
{\em Address} & The start address of the memory. Generally used for debugging. \\
\hline
{\em Size} & Amount of memory you want from the OS. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A void$\ast$ pointer to the start of the memory; 0 if memory allocation failed. 
\end{DoxyReturn}
\mbox{\Hypertarget{ab__memory_8h_a21e3b35f1c8dcdb00715eacb975da0b2}\label{ab__memory_8h_a21e3b35f1c8dcdb00715eacb975da0b2}} 
\index{ab\_memory.h@{ab\_memory.h}!mem\_BeginTemporaryMemory@{mem\_BeginTemporaryMemory}}
\index{mem\_BeginTemporaryMemory@{mem\_BeginTemporaryMemory}!ab\_memory.h@{ab\_memory.h}}
\doxysubsubsection{\texorpdfstring{mem\_BeginTemporaryMemory()}{mem\_BeginTemporaryMemory()}}
{\footnotesize\ttfamily temporary\+\_\+memory mem\+\_\+\+Begin\+Temporary\+Memory (\begin{DoxyParamCaption}\item[{memory\+\_\+arena $\ast$}]{Memory }\end{DoxyParamCaption})}



Indicates the next section of memory is scratch, and will be cleared quickly. 

This must be paired with {\ttfamily \mbox{\hyperlink{ab__memory_8h_a3d43731b8fe9679b5d342cf3c2c77e24}{mem\+\_\+\+End\+Temporary\+Memory()}}}. Memory used between {\ttfamily mem\+\_\+\+Begin\+Tempory\+Memory()} and {\ttfamily \mbox{\hyperlink{ab__memory_8h_a3d43731b8fe9679b5d342cf3c2c77e24}{mem\+\_\+\+End\+Temporary\+Memory()}}} will be wiped. This is generally used for brief scratch memory that\textquotesingle{}s needed within a single function, but is not otherwise needed.

Example Usage\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{temporary\_memory TempMem = \mbox{\hyperlink{ab__memory_8h_a21e3b35f1c8dcdb00715eacb975da0b2}{mem\_BeginTemporaryMemory}}(\&MemoryArena);}
\DoxyCodeLine{}
\DoxyCodeLine{my\_struct *MyStruct = \mbox{\hyperlink{ab__memory_8h_ade8a4ab9a8d221e715d2a0733dd7128f}{mem\_PushStruct}}(\&MemoryArena, my\_struct);}
\DoxyCodeLine{\textcolor{comment}{// Do some scratch work here, using the memory as normal.}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Any memory used since mem\_BeginTemporaryMemory() will be wiped out here.}}
\DoxyCodeLine{\mbox{\hyperlink{ab__memory_8h_a3d43731b8fe9679b5d342cf3c2c77e24}{mem\_EndTemporaryMemory}}(TempMem);}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em Memory} & A pointer to the {\ttfamily memory\+\_\+arena} to use. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A {\ttfamily temporary\+\_\+memory} struct that is used again to end the memory. 
\end{DoxyReturn}
\mbox{\Hypertarget{ab__memory_8h_aac527aab775805919b34095e3f0e0830}\label{ab__memory_8h_aac527aab775805919b34095e3f0e0830}} 
\index{ab\_memory.h@{ab\_memory.h}!mem\_CreateSubArena@{mem\_CreateSubArena}}
\index{mem\_CreateSubArena@{mem\_CreateSubArena}!ab\_memory.h@{ab\_memory.h}}
\doxysubsubsection{\texorpdfstring{mem\_CreateSubArena()}{mem\_CreateSubArena()}}
{\footnotesize\ttfamily memory\+\_\+arena mem\+\_\+\+Create\+Sub\+Arena (\begin{DoxyParamCaption}\item[{memory\+\_\+arena $\ast$}]{Memory,  }\item[{size\+\_\+t}]{Size }\end{DoxyParamCaption})}



Create a {\ttfamily memory\+\_\+arena} inside an existing arena. 


\begin{DoxyParams}{Parameters}
{\em Memory} & A pointer to the existing {\ttfamily memory\+\_\+arena} within which to create a new arena. \\
\hline
{\em Size} & The amount of memory to use for the arena. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A new {\ttfamily memory\+\_\+arena} that may be used just as the parent arena. 
\end{DoxyReturn}
\mbox{\Hypertarget{ab__memory_8h_aa817a02fd268b12b4ca75f15bfe6379c}\label{ab__memory_8h_aa817a02fd268b12b4ca75f15bfe6379c}} 
\index{ab\_memory.h@{ab\_memory.h}!mem\_DeallocateOsMemory@{mem\_DeallocateOsMemory}}
\index{mem\_DeallocateOsMemory@{mem\_DeallocateOsMemory}!ab\_memory.h@{ab\_memory.h}}
\doxysubsubsection{\texorpdfstring{mem\_DeallocateOsMemory()}{mem\_DeallocateOsMemory()}}
{\footnotesize\ttfamily void mem\+\_\+\+Deallocate\+Os\+Memory (\begin{DoxyParamCaption}\item[{void $\ast$}]{Address,  }\item[{size\+\_\+t}]{Size }\end{DoxyParamCaption})}



Return memory to the OS. 


\begin{DoxyParams}{Parameters}
{\em Address} & of the memory from the OS, the return value of \mbox{\hyperlink{ab__memory_8h_a65f300a0fc29f0fb26f7baa536eeef16}{mem\+\_\+\+Allocate\+Os\+Memory()}}. \\
\hline
{\em Size} & Size of the memory to return (Some OS\textquotesingle{}s need this.), should be the same as the parameter from {\ttfamily \mbox{\hyperlink{ab__memory_8h_a65f300a0fc29f0fb26f7baa536eeef16}{mem\+\_\+\+Allocate\+Os\+Memory()}}}. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{ab__memory_8h_a3d43731b8fe9679b5d342cf3c2c77e24}\label{ab__memory_8h_a3d43731b8fe9679b5d342cf3c2c77e24}} 
\index{ab\_memory.h@{ab\_memory.h}!mem\_EndTemporaryMemory@{mem\_EndTemporaryMemory}}
\index{mem\_EndTemporaryMemory@{mem\_EndTemporaryMemory}!ab\_memory.h@{ab\_memory.h}}
\doxysubsubsection{\texorpdfstring{mem\_EndTemporaryMemory()}{mem\_EndTemporaryMemory()}}
{\footnotesize\ttfamily void mem\+\_\+\+End\+Temporary\+Memory (\begin{DoxyParamCaption}\item[{temporary\+\_\+memory}]{Temp\+Mem }\end{DoxyParamCaption})}



Ends the section of temporary memory. 

This will free all the memory used since {\ttfamily \mbox{\hyperlink{ab__memory_8h_a21e3b35f1c8dcdb00715eacb975da0b2}{mem\+\_\+\+Begin\+Temporary\+Memory()}}}. See \mbox{\hyperlink{ab__memory_8h_a21e3b35f1c8dcdb00715eacb975da0b2}{mem\+\_\+\+Begin\+Temporary\+Memory()}} for more details on usage.


\begin{DoxyParams}{Parameters}
{\em Temp\+Mem} & The {\ttfamily temporary\+\_\+memory} struct created with {\ttfamily \mbox{\hyperlink{ab__memory_8h_a21e3b35f1c8dcdb00715eacb975da0b2}{mem\+\_\+\+Begin\+Temporary\+Memory()}}}. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{ab__memory_8h_ada89f9419c002dbe71315a84e72444a1}\label{ab__memory_8h_ada89f9419c002dbe71315a84e72444a1}} 
\index{ab\_memory.h@{ab\_memory.h}!mem\_GetMemoryLeft@{mem\_GetMemoryLeft}}
\index{mem\_GetMemoryLeft@{mem\_GetMemoryLeft}!ab\_memory.h@{ab\_memory.h}}
\doxysubsubsection{\texorpdfstring{mem\_GetMemoryLeft()}{mem\_GetMemoryLeft()}}
{\footnotesize\ttfamily size\+\_\+t mem\+\_\+\+Get\+Memory\+Left (\begin{DoxyParamCaption}\item[{memory\+\_\+arena $\ast$}]{Memory }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Get the amount of memory left in an arena. 


\begin{DoxyParams}{Parameters}
{\em Memory} & A pointer to the {\ttfamily memory\+\_\+arena} to check. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The amount of unused memory in the arena. 
\end{DoxyReturn}
\mbox{\Hypertarget{ab__memory_8h_a3dd694713416bf4f1fc1f0f1433440e0}\label{ab__memory_8h_a3dd694713416bf4f1fc1f0f1433440e0}} 
\index{ab\_memory.h@{ab\_memory.h}!mem\_InitMemory@{mem\_InitMemory}}
\index{mem\_InitMemory@{mem\_InitMemory}!ab\_memory.h@{ab\_memory.h}}
\doxysubsubsection{\texorpdfstring{mem\_InitMemory()}{mem\_InitMemory()}}
{\footnotesize\ttfamily memory\+\_\+arena mem\+\_\+\+Init\+Memory (\begin{DoxyParamCaption}\item[{void $\ast$}]{Start,  }\item[{size\+\_\+t}]{Size }\end{DoxyParamCaption})}



Initialize a memory\+\_\+arena. 

Create a new {\ttfamily memory\+\_\+arena} object from the memory block in the OS. This may be the entire block requested, or part of one.


\begin{DoxyParams}{Parameters}
{\em Start} & The start of the memory block. \\
\hline
{\em Size} & The size of the memory arena. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A new memory\+\_\+arena. 
\end{DoxyReturn}
\mbox{\Hypertarget{ab__memory_8h_a292359d189043396cc92d7c0de05fbec}\label{ab__memory_8h_a292359d189043396cc92d7c0de05fbec}} 
\index{ab\_memory.h@{ab\_memory.h}!mem\_ResetMemory@{mem\_ResetMemory}}
\index{mem\_ResetMemory@{mem\_ResetMemory}!ab\_memory.h@{ab\_memory.h}}
\doxysubsubsection{\texorpdfstring{mem\_ResetMemory()}{mem\_ResetMemory()}}
{\footnotesize\ttfamily void mem\+\_\+\+Reset\+Memory (\begin{DoxyParamCaption}\item[{memory\+\_\+arena $\ast$}]{Memory }\end{DoxyParamCaption})}



Delete everything in a {\ttfamily memory\+\_\+arena} and set the amount of memory used to 0. 

This is used to wipe out everything in a memory arena. This is usually used at the beginning of a control loop to clear the volatile memory.


\begin{DoxyParams}{Parameters}
{\em Memory} & The {\ttfamily memory\+\_\+arena} to wipe. \\
\hline
\end{DoxyParams}
