/**   GENERATED    **/
/** 
    This file was autogenerated. Do not edit directly, your changes will get over-written. 
    This is a single file include. To include the source, add 

#define TEST_SRC

    before including this this file.

    If you are using JSON parsing, add 

#define JSMN_HEADER

    Ensure the jsmn.h header is in your include directory.
**/

#ifndef TAG
#define TAG(...)
#endif

#ifndef STATEMACHINE
#define STATEMACHINE(...)
#endif
#include "ab_memory.h"
#include "ab_file.h"
#include "ab_string.h"

#ifdef JSMN_HEADER
#include "third-party/jsmn.h"
#endif // JSMN_HEADER


#if !defined(_GENERATED_HEADER_)
#define _GENERATED_HEADER_
#ifdef JSMN_HEADER
enum json_flags
{
    JSON_Null = 0,
    JSON_IsLastInList = 1 << 0,
    JSON_DontUseTag = 1 << 1,
    JSON_BaseObject = 1 << 2,
};
#endif

template<typename T>
auto StringToEnum(const char *String) -> T;

template<typename T>
auto StringToEnum(abs_stringptr String) -> T;

u32 StartGroup(char *, u32 MaxLength);
u32 EndGroup(char *, u32 MaxLength, b8 isLast);
#ifdef JSMN_HEADER
s32 ParseJson(memory_arena *VolatileMemory, char const *Json,  size_t JsonLength, jsmntok_t **TokenArray);
#endif

#endif

#if !defined(_AB_GENERATED_HEADER_TEST_)
#define _AB_GENERATED_HEADER_TEST_

/****** Enum EnumClass1 Header *****/
enum class EnumClass1;
const u32 EnumClass1_Count = 3;
template<>
auto StringToEnum<EnumClass1>(const char *String) -> EnumClass1;
template<>
auto StringToEnum<EnumClass1>(abs_stringptr String) -> EnumClass1;
abs_stringptr EnumToString(EnumClass1 EnumToken);
char const* EnumToCString(EnumClass1 EnumToken);
const abs_stringptr EnumClass1_Strings[EnumClass1_Count] = 
{
   {"EC1_Value1", 10},
   {"EC1_Value2", 10},
   {"EC1_Value3", 10},
};

jsmntok_t *JsonToObject(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, jsmntok_t *TokenArray, EnumClass1 *ObjectOut, u32 Unused);
u32
PushJson(char *Json, u32 MaxLength, char const *Tag, EnumClass1 Type, u32 JsonFlags);
const char *EnumToLabel_Test1(EnumClass1 EnumToken);
//const char * EnumClass1_LabelTest1[EnumClass1_Count];
const char * EnumClass1_LabelTest1[EnumClass1_Count] = 
{
    "EC1_Value1",
    "EC1_Value2",
    "EC1_Value3",
};

const char *EnumToLabel_Test2(EnumClass1 EnumToken);
//const char * EnumClass1_LabelTest2[EnumClass1_Count];
const char * EnumClass1_LabelTest2[EnumClass1_Count] = 
{
    "EC1_Value1",
    "EC1_Value2",
    "Test 2 String",
};


/****** Enum EnumClass2 Header *****/
enum class EnumClass2;
const u32 EnumClass2_Count = 3;

/****  StateMachine: SM_SOME_STATEMACHINE ****/
struct state_type;
enum class state_cmd;
/***** Queue: state_cmd ****/
// Creating a circular queue of 10 elements.
struct state_cmd_queue
{
    state_cmd Items[10];
    s32 Front;
    s32 Rear;
};

inline void InitializeQueue(state_cmd_queue *Queue);
inline b8 isQueueEmpty(state_cmd_queue *Queue);
inline b8 isQueueFull(state_cmd_queue *Queue);
b8 EnqueueCommand(state_cmd_queue *Queue, state_cmd Cmd);
state_cmd DequeueCommand(state_cmd_queue *Queue);
/***********/

struct my_type;
enum class my_enum;
#define SM_SOME_STATEMACHINE(name) void name(state_type *State, state_cmd Cmd, my_type *Type, my_enum Enum, int Int, char const *String)
typedef SM_SOME_STATEMACHINE(sm_some_statemachine);

inline b8 GoToState(state_type *State, sm_some_statemachine *NewState);
char const *GetStateName(sm_some_statemachine *StateName);
b8 EnqueueCommand(state_type *State, state_cmd Cmd);
state_cmd DequeueCommand(state_type *State);

SM_SOME_STATEMACHINE(Idle);
SM_SOME_STATEMACHINE(Running);

/*********/

/****  StateMachine: SM_ANOTHER_STATEMACHINE ****/
struct state2_type;
enum class state2_cmd;
/***** Queue: state2_cmd ****/
// Creating a circular queue of 10 elements.
struct state2_cmd_queue
{
    state2_cmd Items[10];
    s32 Front;
    s32 Rear;
};

inline void InitializeQueue(state2_cmd_queue *Queue);
inline b8 isQueueEmpty(state2_cmd_queue *Queue);
inline b8 isQueueFull(state2_cmd_queue *Queue);
b8 EnqueueCommand(state2_cmd_queue *Queue, state2_cmd Cmd);
state2_cmd DequeueCommand(state2_cmd_queue *Queue);
/***********/

enum class state2_enum;
#define SM_ANOTHER_STATEMACHINE(name) void name(state2_type *State, state2_cmd Cmd, state2_enum SomeValue, int Int)
typedef SM_ANOTHER_STATEMACHINE(sm_another_statemachine);

inline b8 GoToState(state2_type *State, sm_another_statemachine *NewState);
char const *GetStateName(sm_another_statemachine *StateName);
b8 EnqueueCommand(state2_type *State, state2_cmd Cmd);
state2_cmd DequeueCommand(state2_type *State);

SM_ANOTHER_STATEMACHINE(Idle2);
SM_ANOTHER_STATEMACHINE(Reset2);

/*********/

/****** Struct Struct1 Header *****/
struct Struct1;
u32 PushJson(char *Json, u32 MaxLength, char const *Tag, const Struct1 &Value, u32 JsonFlags);
struct Struct1_existlist;
jsmntok_t *JsonToObject(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, jsmntok_t *TokenArray, Struct1 *ObjectOut, Struct1_existlist *ItemsExistOut);
u32
JsonArrayToObjectArray(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, Struct1 **ObjectArray, Struct1_existlist **ObjectArrayExist);
struct Struct1_existlist
{
   b8 S11;
   b8 S12;
   b8 S13;
   b8 S14;
   b8 S15;
   b8 S16;
   b8 S17;
   b8 S18;
   b8 S19;
   b8 S1A;
   b8 S1B;
   b8 S1C;
};

/****** Struct Struct2 Header *****/
struct Struct2;

#endif // _AB_GENERATED_HEADER_TEST_

#if defined(TEST_SRC)
#undef TEST_SRC

/****** Enum EnumClass1 Functions *****/
template<>
auto StringToEnum<EnumClass1>(const char *String) -> EnumClass1
{
    u32 StringIndex = abs_FindInList(String, EnumClass1_Count, EnumClass1_Strings, true);
    EnumClass1 Result = EnumClass1::EC1_Value1;
    if(StringIndex < EnumClass1_Count)
    {
        Result = static_cast<EnumClass1>(StringIndex);
    }
    return Result;
}
template<>
auto StringToEnum<EnumClass1>(abs_stringptr String) -> EnumClass1
{
    u32 StringIndex = abs_FindInList(String, EnumClass1_Count, EnumClass1_Strings, true);
    EnumClass1 Result = EnumClass1::EC1_Value1;
    if(StringIndex < EnumClass1_Count)
    {
        Result = static_cast<EnumClass1>(StringIndex);
    }
    return Result;
}
const char *
EnumToCString(EnumClass1 EnumToken)
{
    return EnumClass1_Strings[int(EnumToken)].String;
}

abs_stringptr
EnumToString(EnumClass1 EnumToken)
{
    return EnumClass1_Strings[int(EnumToken)];
}

u32
PushJson(char *Json, u32 MaxLength, char const *Tag, EnumClass1 Type, u32 JsonFlags = 0)
{
    u32 Length = 0;
    b8 isLast = (JsonFlags & JSON_IsLastInList);
    Length += snprintf(Json, MaxLength, "\"%s\":\"%s\"", Tag, EnumToCString(Type));
    if(!isLast) { Json[Length++] = ','; }
    return Length;
}

jsmntok_t *JsonToObject(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, jsmntok_t *TokenArray, EnumClass1 *ObjectOut, u32 Unused)
{
    EnumClass1 Result = static_cast<EnumClass1>(0);
    s32 NumTokensUsed = 0;
    
    s32 TotalTokens = ParseJson(VolatileMemory, Json, JsonLength, &TokenArray);
    if(TokenArray)
    {
        s32 Index = 0;
        if((TokenArray[Index].type == JSMN_OBJECT) &&
           (TotalTokens > 1))
        {
            ++Index;
        }
        if(TokenArray[Index].type == JSMN_STRING)
        {
            s32 TokenLength = (TokenArray[Index].end - TokenArray[Index].start);
            abs_stringptr EnumString = {&Json[TokenArray[Index].start], TokenLength};
            Result = StringToEnum<EnumClass1>(EnumString);
            NumTokensUsed = Index;
        }
        else 
        {
            NumTokensUsed = Index;
        }
    }
    *ObjectOut = Result;
    return TokenArray + NumTokensUsed;
}

const char *
EnumToLabel_Test1(EnumClass1 EnumToken)
{
    return EnumClass1_LabelTest1[int(EnumToken)];
}

const char *
EnumToLabel_Test2(EnumClass1 EnumToken)
{
    return EnumClass1_LabelTest2[int(EnumToken)];
}


/****** Enum EnumClass2 Functions *****/

/****** Queue: state_cmd ****/
inline void
InitializeQueue(state_cmd_queue *Queue)
{
  Queue->Front = Queue->Rear = -1;
}

inline b8
isQueueEmpty(state_cmd_queue *Queue)
{
  b8 Result = (Queue->Front == -1);
  return Result;
}

inline b8 
isQueueFull(state_cmd_queue *Queue)
{
  b8 Result = (Queue->Front == Queue->Rear + 1) ||
  (Queue->Front == 0 && Queue->Rear == (10-1));

  return Result;
}

b8
Enqueue(state_cmd_queue *Queue, state_cmd Cmd)
{
  b8 Result = false;
  if(!isQueueFull(Queue))
  {
    if(Queue->Front == -1)
    {
      Queue->Front = 0;
    }
    Queue->Rear = (Queue->Rear + 1) % 10;
    Queue->Items[Queue->Rear] = Cmd;

    Result = true;
  }
  return Result;    
}

state_cmd
Dequeue(state_cmd_queue *Queue)
{
state_cmd Result = (state_cmd)0;
if(!isQueueEmpty(Queue))
{
Result = Queue->Items[Queue->Front];
if(Queue->Front == Queue->Rear)
{
Queue->Front = Queue->Rear = -1;
}
else 
{
Queue->Front = (Queue->Front + 1) % 10;
}
}

return Result;
}

/***********/

/**** StateMachine: SM_SOME_STATEMACHINE **/
// Function Definitions
inline b8
GoToState(state_type *State, sm_some_statemachine *NewState)
{
    b8 isChanged = false;
    if(NewState && State)
    {
        State->CurrentState = NewState;
        State->isNewState = true;
    }

    return isChanged;
}

char const*
GetStateName(sm_some_statemachine *StateName)
{
if(StateName == Idle) {return "Idle";}
if(StateName == Running) {return "Running";}
return "Unknown";
}

b8
EnqueueCommand(state_type *State, state_cmd Cmd)
{
return Enqueue(&State->CommandQueue, Cmd);
}

state_cmd
DequeueCommand(state_type *State)
{
return Dequeue(&State->CommandQueue);
}


/*********/

/****** Queue: state2_cmd ****/
inline void
InitializeQueue(state2_cmd_queue *Queue)
{
  Queue->Front = Queue->Rear = -1;
}

inline b8
isQueueEmpty(state2_cmd_queue *Queue)
{
  b8 Result = (Queue->Front == -1);
  return Result;
}

inline b8 
isQueueFull(state2_cmd_queue *Queue)
{
  b8 Result = (Queue->Front == Queue->Rear + 1) ||
  (Queue->Front == 0 && Queue->Rear == (10-1));

  return Result;
}

b8
Enqueue(state2_cmd_queue *Queue, state2_cmd Cmd)
{
  b8 Result = false;
  if(!isQueueFull(Queue))
  {
    if(Queue->Front == -1)
    {
      Queue->Front = 0;
    }
    Queue->Rear = (Queue->Rear + 1) % 10;
    Queue->Items[Queue->Rear] = Cmd;

    Result = true;
  }
  return Result;    
}

state2_cmd
Dequeue(state2_cmd_queue *Queue)
{
state2_cmd Result = (state2_cmd)0;
if(!isQueueEmpty(Queue))
{
Result = Queue->Items[Queue->Front];
if(Queue->Front == Queue->Rear)
{
Queue->Front = Queue->Rear = -1;
}
else 
{
Queue->Front = (Queue->Front + 1) % 10;
}
}

return Result;
}

/***********/

/**** StateMachine: SM_ANOTHER_STATEMACHINE **/
// Function Definitions
inline b8
GoToState(state2_type *State, sm_another_statemachine *NewState)
{
    b8 isChanged = false;
    if(NewState && State)
    {
        State->CurrentState = NewState;
        State->isNewState = true;
    }

    return isChanged;
}

char const*
GetStateName(sm_another_statemachine *StateName)
{
if(StateName == Idle2) {return "Idle2";}
if(StateName == Reset2) {return "Reset2";}
return "Unknown";
}

b8
EnqueueCommand(state2_type *State, state2_cmd Cmd)
{
return Enqueue(&State->CommandQueue, Cmd);
}

state2_cmd
DequeueCommand(state2_type *State)
{
return Dequeue(&State->CommandQueue);
}


/*********/

/****** Struct Struct1 Functions *****/
u32 PushJson(char *Json, u32 MaxLength, char const*Tag, const Struct1 &Value, u32 JsonFlags = 0)
{
    u32 Length = 0;
    b8 isLast = (JsonFlags & JSON_IsLastInList);
    if(JsonFlags & JSON_BaseObject)
    {
        Json[Length++] = '{';
    }
    if(!(JsonFlags & JSON_DontUseTag))
    {
          Length += snprintf(&Json[Length], MaxLength, "\"%s\":", Tag);
    }
    Length += StartGroup(&Json[Length], (MaxLength - Length));
Length += snprintf(&Json[Length], (MaxLength - Length), "\"S11\":%d,",  (Value.S11));
Length += snprintf(&Json[Length], (MaxLength - Length), "\"S12\":%d,",  (Value.S12));
Length += snprintf(&Json[Length], (MaxLength - Length), "\"S13\":%d,",  (Value.S13));
Length += PushJson(&Json[Length], (MaxLength - Length), "S14",  (Value.S14), JSON_Null);
Length += PushJson(&Json[Length], (MaxLength - Length), "S15",  (Value.S15), JSON_Null);
Length += PushJson(&Json[Length], (MaxLength - Length), "S16",  (Value.S16), JSON_Null);
if(Value.S17)
{
    Length += PushJson(&Json[Length], (MaxLength - Length), "S17", *(Value.S17), JSON_Null);
}
if(Value.S18)
{
Length += snprintf(&Json[Length], (MaxLength - Length), "\"S18\":\"%s\",", (Value.S18));
}
if(Value.S19)
{
Length += snprintf(&Json[Length], (MaxLength - Length), "\"S19\":\"%s\",", (Value.S19));
}
{
size_t StringLen = strnlen_s(Value.S1A, 10);
Length += snprintf(&Json[Length], (MaxLength - Length), "\"S1A\":\"%.*s\",", (s32)StringLen, Value.S1A);
}
{
size_t StringLen = strnlen_s(Value.S1B, 10);
Length += snprintf(&Json[Length], (MaxLength - Length), "\"S1B\":\"%.*s\",", (s32)StringLen, Value.S1B);
}
{
size_t StringLen = strnlen_s(Value.S1C, 10);
Length += snprintf(&Json[Length], (MaxLength - Length), "\"S1C\":\"%.*s\" ", (s32)StringLen, Value.S1C);
}
    Length += EndGroup(&Json[Length], (MaxLength - Length), isLast);
    if(JsonFlags & JSON_BaseObject)
    {
        Json[Length++] = '}';
    }
    return Length;
}

jsmntok_t *JsonToObject(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, jsmntok_t *TokenArray, Struct1 *ObjectOut, Struct1_existlist *ItemsExistOut)
{
    Struct1_existlist* ItemExists = PushStruct(VolatileMemory, Struct1_existlist);
    s32 NumTokensProcessed =  ParseJson(VolatileMemory, Json, JsonLength, &TokenArray);
    jsmntok_t *Token = TokenArray;
    if(Token)
    {
        s32 NumTokensToProcess = Token->size;
        s32 ObjectEndPosition = Token->end;
        for(s32 Index = 0; Index < NumTokensToProcess; ++Index)
        {
            ++Token;
            s32 TokenLength = Token->end - Token->start;
            
            if((areStringsEqual(&Json[Token->start], TokenLength, "S11",(ArrayCount("S11")-1), true)) && 
               (((Token+1)->type == JSMN_STRING) || ((Token+1)->type == JSMN_OBJECT))) 
{
            ItemExists->S11 = true;
Token = JsonToObject(VolatileMemory, Json, JsonLength, ++Token,  &ObjectOut->S11,0);
}

            if((areStringsEqual(&Json[Token->start], TokenLength, "S12",(ArrayCount("S12")-1), true)) && 
               (((Token+1)->type == JSMN_STRING) || ((Token+1)->type == JSMN_OBJECT))) 
{
            ItemExists->S12 = true;
Token = JsonToObject(VolatileMemory, Json, JsonLength, ++Token,  &ObjectOut->S12,0);
}

            if((areStringsEqual(&Json[Token->start], TokenLength, "S13",(ArrayCount("S13")-1), true)) && 
               (((Token+1)->type == JSMN_STRING) || ((Token+1)->type == JSMN_OBJECT))) 
{
            ItemExists->S13 = true;
Token = JsonToObject(VolatileMemory, Json, JsonLength, ++Token,  &ObjectOut->S13,0);
}

            if((areStringsEqual(&Json[Token->start], TokenLength, "S14",(ArrayCount("S14")-1), true)) && 
               (((Token+1)->type == JSMN_STRING) || ((Token+1)->type == JSMN_OBJECT))) 
{
            ItemExists->S14 = true;
Token = JsonToObject(VolatileMemory, Json, JsonLength, ++Token,  &ObjectOut->S14,0);
}

            if((areStringsEqual(&Json[Token->start], TokenLength, "S15",(ArrayCount("S15")-1), true)) && 
               (((Token+1)->type == JSMN_STRING) || ((Token+1)->type == JSMN_OBJECT))) 
{
            ItemExists->S15 = true;
Token = JsonToObject(VolatileMemory, Json, JsonLength, ++Token,  &ObjectOut->S15,0);
}

            if((areStringsEqual(&Json[Token->start], TokenLength, "S16",(ArrayCount("S16")-1), true)) && 
               (((Token+1)->type == JSMN_STRING) || ((Token+1)->type == JSMN_OBJECT))) 
{
            ItemExists->S16 = true;
Token = JsonToObject(VolatileMemory, Json, JsonLength, ++Token,  &ObjectOut->S16,0);
}

            if((areStringsEqual(&Json[Token->start], TokenLength, "S17",(ArrayCount("S17")-1), true)) && 
               (((Token+1)->type == JSMN_STRING) || ((Token+1)->type == JSMN_OBJECT))&& 
(ObjectOut->S17)) 
{
            ItemExists->S17 = true;
Token = JsonToObject(VolatileMemory, Json, JsonLength, ++Token,   ObjectOut->S17,0);
}

            if((areStringsEqual(&Json[Token->start], TokenLength, "S1A",(ArrayCount("S1A")-1), true)) && 
               ((Token+1)->type == JSMN_STRING)) 
{
            ItemExists->S1A = true;
    ++Token;
    TokenLength = Token->end - Token->start;
    s32 Length = MINIMUM(TokenLength, (10-1));
    strncpy(ObjectOut->S1A, &Json[Token->start], Length);
    ObjectOut->S1A[Length] = 0;
}


}
}
if(ItemsExistOut)
{
    *ItemsExistOut = *ItemExists;
}
return Token;
}

u32
JsonArrayToObjectArray(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, Struct1 **ObjectArray, Struct1_existlist **ObjectArrayExists)
{
   u32 NumberOfObjects = 0;
            
    jsmntok_t *TokenArray = 0;
    s32 NumTokensParsed = ParseJson(VolatileMemory, Json, JsonLength, &TokenArray);
    
    if(TokenArray)
    {
        u32 TokenIndex = 0;
        jsmntok_t *Token = &TokenArray[TokenIndex++];
        if(Token->type == JSMN_OBJECT)
        {
            // NOTE(Amos): Next token will be a string; not checking label strings yet.
            ++TokenIndex;
            Token = &TokenArray[TokenIndex++];
        }
        
        if(Token->type == JSMN_ARRAY)
        {
            NumberOfObjects= Token->size;
            ++Token;
        }
        else if(Token->type == JSMN_OBJECT)
        {
            NumberOfObjects = 1;
        }
        
        if (!(*ObjectArray))
        {
            *ObjectArray = PushArray(VolatileMemory, NumberOfObjects, Struct1);
        }
        if (!(*ObjectArrayExists))
        {
            *ObjectArrayExists = PushArray(VolatileMemory, NumberOfObjects, Struct1_existlist);
        }
        
        for(u32 Index = 0; Index < NumberOfObjects; ++Index)
        {
            Token = JsonToObject(VolatileMemory, Json, JsonLength, Token, &(*ObjectArray)[Index],&(*ObjectArrayExists)[Index]);
            ++Token;
        }
    }
    return NumberOfObjects;
}

/****** Struct Struct2 Functions *****/

#endif // TEST_SRC
