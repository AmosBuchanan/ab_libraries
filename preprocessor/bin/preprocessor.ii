# 1 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp"
# 1 "/home/amos/prog/c/amos_libraries/preprocessor//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp"


# 1 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_common.h" 1
# 13 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_common.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 424 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 427 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 428 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 429 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 425 "/usr/include/features.h" 2 3 4
# 448 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 449 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4



# 30 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 130 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 131 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 28 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 68 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 81 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 97 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 111 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdint.h" 2 3 4
# 14 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_common.h" 2
# 1 "/usr/include/wchar.h" 1 3 4
# 27 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 75 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
typedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));
# 87 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
typedef __float128 _Float128;
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 207 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef float _Float32;
# 244 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float64;
# 261 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 278 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 31 "/usr/include/wchar.h" 2 3 4




# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 216 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 36 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 39 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 3 4
typedef unsigned int wint_t;
# 42 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h" 2 3 4

typedef __mbstate_t mbstate_t;
# 43 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 44 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 47 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 50 "/usr/include/wchar.h" 2 3 4
# 79 "/usr/include/wchar.h" 3 4
extern "C" {



struct tm;



extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) throw ();


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) throw ();



extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    locale_t __loc) throw ();

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, locale_t __loc) throw ();




extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) throw ();







extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, locale_t __loc) throw ();


extern wchar_t *wcsdup (const wchar_t *__s) throw () __attribute__ ((__malloc__));




extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
# 181 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));




extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcspbrk (const wchar_t *__wcs,
         const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsstr (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (const wchar_t *__s) throw () __attribute__ ((__pure__));




extern "C++" wchar_t *wcswcs (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcswcs (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
# 240 "/usr/include/wchar.h" 3 4
extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));





extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wmemchr (const wchar_t *__s, wchar_t __c,
         size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();




extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     throw ();





extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();
# 337 "/usr/include/wchar.h" 3 4
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();





extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (const wchar_t *__s, size_t __n) throw ();





extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();



extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
# 396 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) throw ();



extern _Float64 wcstof64 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) throw ();



extern _Float128 wcstof128 (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();



extern _Float32x wcstof32x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();



extern _Float64x wcstof64x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
# 428 "/usr/include/wchar.h" 3 4
extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();




__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();





__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();






extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     locale_t __loc) throw ();

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, locale_t __loc)
     throw ();

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, locale_t __loc)
     throw ();

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, locale_t __loc)
     throw ();

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();
# 511 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) throw ();



extern _Float64 wcstof64_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) throw ();



extern _Float128 wcstof128_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();



extern _Float32x wcstof32x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();



extern _Float64x wcstof64x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();
# 551 "/usr/include/wchar.h" 3 4
extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();
# 567 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();





extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     throw () ;
# 673 "/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
# 727 "/usr/include/wchar.h" 3 4
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
# 782 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 808 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 818 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);






extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) throw ();




extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) throw ();
# 857 "/usr/include/wchar.h" 3 4
}
# 15 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_common.h" 2
# 35 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_common.h"

# 35 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_common.h"
typedef wchar_t wchar;

typedef int8_t b8;

typedef int8_t s8;
typedef uint8_t u8;

typedef int16_t s16;
typedef uint16_t u16;

typedef int32_t s32;
typedef uint32_t u32;

typedef int64_t s64;
typedef uint64_t u64;

typedef float r32;
typedef double r64;

const r32 TAU = 6.2831853071f;
# 4 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp" 2


# 1 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory.h" 1
# 13 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory.h"
# 1 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_common.h" 1
# 14 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory.h" 2

struct memory_arena
{
 void *Start;
 size_t Size;
 size_t Used;
};

struct temporary_memory
{
 memory_arena* Arena;
 size_t Used;
};

void *abm_AllocateOsMemory(void *Address, size_t Size);
void abm_DeallocateOsMemory(void *Address, size_t Size);




void *abm_PushSize_(memory_arena *Memory, size_t Size, b8 ClearMemory = true);
memory_arena abm_InitMemory(void *Start, size_t Size);
void abm_ResetMemory(memory_arena *Memory);
inline size_t abm_GetMemoryLeft(memory_arena *Memory);

temporary_memory abm_BeginTemporaryMemory(memory_arena *Memory);
void abm_EndTemporaryMemory(temporary_memory TempMem);






# 1 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory_linux.h" 1
# 10 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory_linux.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/mman.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/sys/mman.h" 2 3 4




# 29 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
typedef __off_t off_t;







typedef __mode_t mode_t;



# 1 "/usr/include/x86_64-linux-gnu/bits/mman.h" 1 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/mman.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mman-linux.h" 1 3 4
# 115 "/usr/include/x86_64-linux-gnu/bits/mman-linux.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mman-shared.h" 1 3 4
# 42 "/usr/include/x86_64-linux-gnu/bits/mman-shared.h" 3 4
extern "C" {



int memfd_create (const char *__name, unsigned int __flags) throw ();



int mlock2 (const void *__addr, size_t __length, unsigned int __flags) throw ();





int pkey_alloc (unsigned int __flags, unsigned int __access_rights) throw ();



int pkey_set (int __key, unsigned int __access_rights) throw ();



int pkey_get (int __key) throw ();



int pkey_free (int __key) throw ();



int pkey_mprotect (void *__addr, size_t __len, int __prot, int __pkey) throw ();

}
# 115 "/usr/include/x86_64-linux-gnu/bits/mman-linux.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/mman.h" 2 3 4
# 42 "/usr/include/x86_64-linux-gnu/sys/mman.h" 2 3 4




extern "C" {
# 57 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
extern void *mmap (void *__addr, size_t __len, int __prot,
     int __flags, int __fd, __off_t __offset) throw ();
# 70 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
extern void *mmap64 (void *__addr, size_t __len, int __prot,
       int __flags, int __fd, __off64_t __offset) throw ();




extern int munmap (void *__addr, size_t __len) throw ();




extern int mprotect (void *__addr, size_t __len, int __prot) throw ();







extern int msync (void *__addr, size_t __len, int __flags);




extern int madvise (void *__addr, size_t __len, int __advice) throw ();



extern int posix_madvise (void *__addr, size_t __len, int __advice) throw ();




extern int mlock (const void *__addr, size_t __len) throw ();


extern int munlock (const void *__addr, size_t __len) throw ();




extern int mlockall (int __flags) throw ();



extern int munlockall (void) throw ();







extern int mincore (void *__start, size_t __len, unsigned char *__vec)
     throw ();
# 133 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
extern void *mremap (void *__addr, size_t __old_len, size_t __new_len,
       int __flags, ...) throw ();



extern int remap_file_pages (void *__start, size_t __size, int __prot,
        size_t __pgoff, int __flags) throw ();




extern int shm_open (const char *__name, int __oflag, mode_t __mode);


extern int shm_unlink (const char *__name);

}
# 11 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory_linux.h" 2

# 11 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory_linux.h"
void *abm_AllocateOsMemory(void *Address, size_t Size)
{
    void* MemoryStart = mmap(Address, Size,
                             
# 14 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory_linux.h" 3 4
                            0x1 
# 14 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory_linux.h"
                                      | 
# 14 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory_linux.h" 3 4
                                        0x2
# 14 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory_linux.h"
                                                  ,
                             
# 15 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory_linux.h" 3 4
                            0x20 
# 15 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory_linux.h"
                                          | 
# 15 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory_linux.h" 3 4
                                            0x02
# 15 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory_linux.h"
                                                       ,
                             -1, 0);

    return MemoryStart;

}

void
abm_DeallocateOsMemory(void *Address, size_t Size)
{
    munmap(Address, Size);
}
# 48 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory.h" 2





memory_arena
abm_InitMemory(void *Start, size_t Size)
{
    memory_arena Memory = {};
    Memory.Start = Start;
    Memory.Size = Size;
    Memory.Used = 0;

    return Memory;
}

memory_arena
abm_CreateSubArena(memory_arena *Memory, size_t Size)
{
    memory_arena SubArena = {};
    SubArena.Start = abm_PushSize_(Memory, Size);
    SubArena.Size = Size;
    SubArena.Used = 0;

    return SubArena;
}

void *
abm_PushSize_(memory_arena *Memory, size_t Size, b8 ClearMemory)
{
    void* Result = 0;

    ;
    Result = (((u8*)Memory->Start) + Memory->Used);
    Memory->Used += Size;

    if(ClearMemory)
    {
        for(size_t Index = 0; Index < Size; ++Index)
        {
            ((u8*)Result)[Index] = 0;
        }
    }

    return Result;
}

temporary_memory
abm_BeginTemporaryMemory(memory_arena *Memory)
{
    temporary_memory Result = {};
    Result.Arena = Memory;
    Result.Used = Memory->Used;

    return Result;
}

void
abm_EndTemporaryMemory(temporary_memory TempMem)
{
    TempMem.Arena->Used = TempMem.Used;
}


void
abm_ResetMemory(memory_arena *Memory)
{
    Memory->Used = 0;
}

inline size_t
abm_GetMemoryLeft(memory_arena *Memory)
{
    size_t Result = Memory->Size - Memory->Used;

    return Result;
}
# 7 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp" 2


# 1 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_string.h" 1



# 1 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory.h" 1
# 47 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory.h"
# 1 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory_linux.h" 1
# 48 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory.h" 2
# 5 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_string.h" 2

u32 abs_StringLength(char const *x, u32 MaxLength);


struct abs_stringptr
{
    char const* String;
    u32 Length;

    abs_stringptr(void) = default;
    constexpr abs_stringptr(char const *S, u32 L) : String{S}, Length{L} {}
    constexpr abs_stringptr(char const *S, s32 L) : String{S}, Length{(u32)L} {}
    abs_stringptr(char const* x) {this->String = x; this->Length = abs_StringLength(x, 1024);}
    abs_stringptr(char * const x) {this->String = x; this->Length = abs_StringLength(x, 1024);}
    abs_stringptr(const char &x) {}
    operator char const *() const { return this->String;}
};


b8
abs_AreStringFragmentsEqual(char const *String1, char const *String2, u32 MaxLength, b8 isCaseInsensitive);

b8
abs_AreStringsEqual(const char *String1, u32 String1Len, const char *String2, u32 String2Len, b8 isCaseInsensitive);

u32
abs_FindInList(abs_stringptr String, u32 ListCount, const abs_stringptr *List, b8 isCaseInsensitive = false);

u32
abs_FindInList(const char *SearchString, u32 ListCount, const abs_stringptr *List, b8 isCaseInsensitive = false);

char *abs_StringCopy( char * dest, const char * src, size_t count );

abs_stringptr
abs_CreateStringPtr(memory_arena *Memory, const char *String);




# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4


# 28 "/usr/include/string.h" 3 4
extern "C" {




# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 42 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 88 "/usr/include/string.h" 3 4
}
# 98 "/usr/include/string.h" 3 4
extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 121 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 203 "/usr/include/string.h" 3 4
extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 223 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 250 "/usr/include/string.h" 3 4
}
# 260 "/usr/include/string.h" 3 4
extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 272 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 300 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 327 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 368 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) throw ();
# 420 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, locale_t __l) throw ();



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4






extern "C" {



extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 66 "/usr/include/strings.h" 3 4
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 94 "/usr/include/strings.h" 3 4
}
# 104 "/usr/include/strings.h" 3 4
extern int ffs (int __i) throw () __attribute__ ((__const__));





extern int ffsl (long int __l) throw () __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));


}
# 432 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 498 "/usr/include/string.h" 3 4
}
# 45 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_string.h" 2


# 46 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_string.h"
b8
abs_AreStringFragmentsEqual(char const *String1, char const *String2, u32 MaxLength, b8 isCaseInsensitive)
{
    b8 isMatch = false;
    const char *CompAt = String1;
    const char *SearchAt = String2;
    u32 StringLength = 0;

    while(*CompAt && *SearchAt &&
          StringLength < MaxLength)
    {
        char CompAtChar = *CompAt;
        char SearchAtChar = *SearchAt;
        if(isCaseInsensitive)
        {
            if(CompAtChar >= 'a' &&
               CompAtChar <= 'z')
            {
                CompAtChar -= 32;
            }
            if(SearchAtChar >= 'a' &&
               SearchAtChar <= 'z')
            {
                SearchAtChar -= 32;
            }
        }
        if(CompAtChar == SearchAtChar)
        {
            isMatch = true;
            ++CompAt;
            ++SearchAt;
        }
        else
        {
            isMatch = false;
            break;
        }

        ++StringLength;
    }

    return (isMatch && (StringLength == MaxLength));

}

b8
abs_AreStringsEqual(char const *String1, u32 String1Len, char const *String2, u32 String2Len, b8 isCaseInsensitive)
{
    b8 isMatch = false;
    if(String1Len == String2Len)
    {
        isMatch = abs_AreStringFragmentsEqual(String1, String2, String1Len, isCaseInsensitive);

    }

    return isMatch;
}

b8
abs_AreStringsEqual(char const *String1, u32 String1Len, char const *String2, u32 String2Len)
{
    return abs_AreStringsEqual(String1, String1Len, String2, String2Len, true);
}

b8
abs_AreStringsEqual(abs_stringptr String1, abs_stringptr String2, b8 isCaseInsensitive)
{
    return abs_AreStringsEqual(String1.String, String1.Length, String2.String, String2.Length, isCaseInsensitive);
}

b8
abs_AreStringsEqual(abs_stringptr String1, abs_stringptr String2)
{
    return abs_AreStringsEqual(String1.String, String1.Length, String2.String, String2.Length, false);
}

b8
abs_AreStringsEqual(char const *String, u32 StringLen, abs_stringptr StringPtr)
{
    return abs_AreStringsEqual(String, StringLen, StringPtr.String, StringPtr.Length, true);
}

u32
abs_StringLength(char const *x, u32 MaxLength)
{
    char const *At = x;
    u32 Length = 0;
    while(Length < MaxLength)
    {
        if(*At++) {++Length;}
        else {break;}
    }

    return Length;
}

u32
abs_FindInList(abs_stringptr String, u32 ListCount, const abs_stringptr *List, b8 isCaseInsensitive)
{
    u32 MatchIndex = ListCount;

    for(u32 Index = 0;
        Index < ListCount;
        ++Index)
    {
        if(abs_AreStringsEqual(String.String, String.Length, List[Index].String, List[Index].Length, isCaseInsensitive))
        {
            MatchIndex = Index;
            break;
        }
    }

    return MatchIndex;
}

u32
abs_FindInList(const char *SearchString, u32 ListCount, const abs_stringptr *List, b8 isCaseInsensitive)
{
    u32 MatchIndex = ListCount;
    u32 SearchStringLen = (u32)strlen(SearchString);

    for(u32 Index = 0;
        Index < ListCount;
        ++Index)
    {
        if(abs_AreStringsEqual(SearchString, SearchStringLen, List[Index], (u32)strlen(List[Index]), isCaseInsensitive))
        {
            MatchIndex = Index;
            break;
        }
    }

    return MatchIndex;
}

char *abs_StringCopy(char * dest, const char *src, size_t count)
{
    return strncpy(dest, src, count);
}

abs_stringptr
abs_CreateStringPtr(memory_arena *Memory, const char *String)
{
    u32 Length = abs_StringLength(String, (abm_GetMemoryLeft(Memory)-1));
    char *StringPtr = (char*)abm_PushSize_(Memory, (Length+1)*sizeof(char));

    abs_StringCopy(StringPtr, String, Length+1);
    abs_stringptr Result = abs_stringptr(StringPtr, Length);

    return Result;
}

abs_stringptr
abs_Capitalize(abs_stringptr String, memory_arena *Memory)
{
    char *NewString = (char*)abm_PushSize_(Memory, (String.Length)*sizeof(char));
    for(u32 i = 0; i < String.Length; ++i)
    {
        if(String.String[i] >= 'a' && String.String[i] <= 'z')
        {
            NewString[i] = String.String[i] - 0x20;
        }
        else
        {
            NewString[i] = String.String[i];
        }
    }
    abs_stringptr Result = {NewString, String.Length};

    return Result;

}

abs_stringptr
abs_Lowercase(abs_stringptr String, memory_arena *Memory)
{
    char *NewString = (char*)abm_PushSize_(Memory, (String.Length)*sizeof(char));
    for(u32 i = 0; i < String.Length; ++i)
    {
        if(String.String[i] >= 'A' && String.String[i] <= 'Z')
        {
            NewString[i] = String.String[i] + 0x20;
        }
        else
        {
            NewString[i] = String.String[i];
        }
    }
    abs_stringptr Result = {NewString, String.Length};

    return Result;

}
# 10 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp" 2


# 1 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_file.h" 1
# 10 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_file.h"
# 1 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 1
# 179 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 1 3 4
# 99 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 3 4

# 99 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 180 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 149 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 426 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 437 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 181 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 2





# 185 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
typedef char *STBSP_SPRINTFCB(const char *buf, void *user, int len);





extern "C" int stbsp_vsprintf(char *buf, char const *fmt, va_list va);
extern "C" int stbsp_vsnprintf(char *buf, int count, char const *fmt, va_list va);
extern "C" int stbsp_sprintf(char *buf, char const *fmt, ...);
extern "C" int stbsp_snprintf(char *buf, int count, char const *fmt, ...);

extern "C" int stbsp_vsprintfcb(STBSP_SPRINTFCB *callback, void *user, char *buf, char const *fmt, va_list va);
extern "C" void stbsp_set_separators(char comma, char period);
# 11 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_file.h" 2
# 1 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory.h" 1
# 47 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory.h"
# 1 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory_linux.h" 1
# 48 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory.h" 2
# 12 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_file.h" 2

struct file_data
{
    size_t Size;
    u32 FileIndex;
    char FileName[50];
    char *FileData;
};



struct file_list;

file_list *abf_InitializeFileList(memory_arena *Memory, const char *Path);
b8 abf_GetNextFile(file_list *FileList, file_data *FileDataOut);
void abf_ReleaseFileList(file_list *FileList);
# 36 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_file.h"
# 1 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_file_linux.h" 1





# 1 "/usr/include/glob.h" 1 3 4
# 23 "/usr/include/glob.h" 3 4

# 23 "/usr/include/glob.h" 3 4
extern "C" {
# 80 "/usr/include/glob.h" 3 4
struct stat;

typedef struct
  {
    size_t gl_pathc;
    char **gl_pathv;
    size_t gl_offs;
    int gl_flags;



    void (*gl_closedir) (void *);

    struct dirent *(*gl_readdir) (void *);



    void *(*gl_opendir) (const char *);

    int (*gl_lstat) (const char *__restrict, struct stat *__restrict);
    int (*gl_stat) (const char *__restrict, struct stat *__restrict);




  } glob_t;



struct stat64;

typedef struct
  {
    size_t gl_pathc;
    char **gl_pathv;
    size_t gl_offs;
    int gl_flags;



    void (*gl_closedir) (void *);

    struct dirent64 *(*gl_readdir) (void *);



    void *(*gl_opendir) (const char *);

    int (*gl_lstat) (const char *__restrict, struct stat64 *__restrict);
    int (*gl_stat) (const char *__restrict, struct stat64 *__restrict);




  } glob64_t;
# 146 "/usr/include/glob.h" 3 4
extern int glob (const char *__restrict __pattern, int __flags,
   int (*__errfunc) (const char *, int),
   glob_t *__restrict __pglob) throw ();


extern void globfree (glob_t *__pglob) throw ();
# 162 "/usr/include/glob.h" 3 4
extern int glob64 (const char *__restrict __pattern, int __flags,
     int (*__errfunc) (const char *, int),
     glob64_t *__restrict __pglob) throw ();

extern void globfree64 (glob64_t *__pglob) throw ();
# 176 "/usr/include/glob.h" 3 4
extern int glob_pattern_p (const char *__pattern, int __quote) throw ();


}
# 7 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_file_linux.h" 2
# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;
# 75 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 93 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __off64_t off64_t;




typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 128 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 132 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 146 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 178 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 194 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 62 "/usr/include/endian.h" 2 3 4
# 195 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4







struct timespec
{
  __time_t tv_sec;
  __syscall_slong_t tv_nsec;
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern "C" {
# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 126 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
}
# 198 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 41 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sysmacros.h" 1 3 4
# 42 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 2 3 4
# 71 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
extern "C" {

extern unsigned int gnu_dev_major (__dev_t __dev) throw () __attribute__ ((__const__));
extern unsigned int gnu_dev_minor (__dev_t __dev) throw () __attribute__ ((__const__));
extern __dev_t gnu_dev_makedev (unsigned int __major, unsigned int __minor) throw () __attribute__ ((__const__));
# 85 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
}
# 206 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4






typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 246 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 77 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 99 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
};
# 78 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 118 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
struct __pthread_mutex_s
{
  int __lock ;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;
 




  short __spins; short __elision;
  __pthread_list_t __list;
# 145 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
 
};




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 255 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


}
# 8 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_file_linux.h" 2
# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 99 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern "C" {

# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 91 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 106 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 115 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
  };



struct stat64
  {
    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;






    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;





    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 164 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];



  };
# 102 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 205 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) throw () __attribute__ ((__nonnull__ (2)));
# 224 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) throw () __attribute__ ((__nonnull__ (2)));







extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     throw () __attribute__ ((__nonnull__ (2, 3)));
# 249 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     throw () __attribute__ ((__nonnull__ (2, 3)));







extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));
# 272 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int chmod (const char *__file, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) throw ();





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) throw ();




extern __mode_t getumask (void) throw ();



extern int mkdir (const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) throw () __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     throw () __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, const struct timespec __times[2]) throw ();
# 395 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     throw () __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename,
      struct stat *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename,
       struct stat *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename,
         struct stat *__stat_buf, int __flag)
     throw () __attribute__ ((__nonnull__ (3, 4)));
# 428 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     throw () __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, const char *__filename,
        struct stat64 *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, const char *__filename,
         struct stat64 *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     throw () __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) throw () __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     throw () __attribute__ ((__nonnull__ (3, 5)));
# 530 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
}
# 9 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_file_linux.h" 2
# 1 "/usr/include/fcntl.h" 1 3 4
# 28 "/usr/include/fcntl.h" 3 4
extern "C" {






# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };



# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 2 3 4


struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 39 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4
# 265 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_PGRP,
    F_OWNER_GID = F_OWNER_PGRP
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
# 346 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/linux/falloc.h" 1 3 4
# 347 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4



struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;

  unsigned char f_handle[0];
};
# 380 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
extern "C" {




extern __ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    throw ();






extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);






extern __ssize_t vmsplice (int __fdout, const struct iovec *__iov,
      size_t __count, unsigned int __flags);





extern __ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
    __off64_t *__offout, size_t __len,
    unsigned int __flags);





extern __ssize_t tee (int __fdin, int __fdout, size_t __len,
        unsigned int __flags);






extern int fallocate (int __fd, int __mode, __off_t __offset, __off_t __len);
# 435 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);




extern int name_to_handle_at (int __dfd, const char *__name,
         struct file_handle *__handle, int *__mnt_id,
         int __flags) throw ();





extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
         int __flags);



}
# 61 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 78 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 79 "/usr/include/fcntl.h" 2 3 4
# 147 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 157 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 167 "/usr/include/fcntl.h" 3 4
extern int open64 (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 181 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 192 "/usr/include/fcntl.h" 3 4
extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 203 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 213 "/usr/include/fcntl.h" 3 4
extern int creat64 (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 232 "/usr/include/fcntl.h" 3 4
extern int lockf (int __fd, int __cmd, off_t __len);
# 241 "/usr/include/fcntl.h" 3 4
extern int lockf64 (int __fd, int __cmd, off64_t __len);







extern int posix_fadvise (int __fd, off_t __offset, off_t __len,
     int __advise) throw ();
# 261 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
       int __advise) throw ();
# 271 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
# 282 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);
# 293 "/usr/include/fcntl.h" 3 4
}
# 10 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_file_linux.h" 2
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4
extern "C" {
# 205 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 206 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 210 "/usr/include/unistd.h" 2 3 4
# 229 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 230 "/usr/include/unistd.h" 2 3 4
# 277 "/usr/include/unistd.h" 3 4
typedef __socklen_t socklen_t;
# 290 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;
# 337 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) throw ();
# 348 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 379 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 407 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) throw () ;




extern int pipe2 (int __pipedes[2], int __flags) throw () ;
# 435 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
# 447 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
# 472 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) throw () ;
# 514 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw () ;





extern char *get_current_dir_name (void) throw ();







extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) throw () ;


extern int dup2 (int __fd, int __fd2) throw ();




extern int dup3 (int __fd, int __fd2, int __flags) throw ();



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) throw () __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     throw () __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) throw () ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 613 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();


extern __pid_t getpgrp (void) throw ();


extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
# 663 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) throw ();






extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () ;



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw () ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw () ;




extern int seteuid (__uid_t __uid) throw () ;






extern int setgid (__gid_t __gid) throw () ;




extern int setregid (__gid_t __rgid, __gid_t __egid) throw () ;




extern int setegid (__gid_t __gid) throw () ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw () ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw () ;






extern __pid_t fork (void) throw ();







extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) throw ();




extern int ttyslot (void) throw ();




extern int link (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) throw () __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern "C" {







extern char *optarg;
# 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw () __attribute__ ((__nonnull__ (2, 3)));

}
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 2 3 4

extern "C" {
# 49 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
}
# 873 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) throw () ;





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) throw ();


extern int revoke (const char *__file) throw () __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () ;






extern int chroot (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) throw ();






extern long int gethostid (void);


extern void sync (void) throw ();





extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();
# 994 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1006 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1017 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) throw () ;
# 1027 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) throw () ;
# 1038 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) throw () ;





extern void *sbrk (intptr_t __delta) throw ();
# 1059 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
# 1110 "/usr/include/unistd.h" 3 4
ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
    int __outfd, __off64_t *__poutoff,
    size_t __length, unsigned int __flags);





extern int fdatasync (int __fildes);







extern char *crypt (const char *__key, const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__glibc_block, int __edflag)
     throw () __attribute__ ((__nonnull__ (1)));






extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));
# 1167 "/usr/include/unistd.h" 3 4
int getentropy (void *__buffer, size_t __length) ;







}
# 11 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_file_linux.h" 2
# 1 "/usr/include/malloc.h" 1 3 4
# 23 "/usr/include/malloc.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 24 "/usr/include/malloc.h" 2 3 4
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/stdio.h" 2 3 4

extern "C" {



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/libio.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 2 3 4






typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 36 "/usr/include/x86_64-linux-gnu/bits/libio.h" 2 3 4
# 149 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;




typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
  __off64_t _offset;







  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;

  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 337 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 433 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 462 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 524 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
}
# 42 "/usr/include/stdio.h" 2 3 4
# 78 "/usr/include/stdio.h" 3 4
typedef _G_fpos_t fpos_t;




typedef _G_fpos64_t fpos64_t;
# 131 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 132 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;






extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();







extern FILE *tmpfile (void) ;
# 169 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;




extern char *tmpnam_r (char *__s) throw () ;
# 190 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 213 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 223 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 232 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 256 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();
# 420 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 477 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);
# 495 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 506 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 517 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 537 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 587 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 662 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 673 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 707 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 750 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;



extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;







extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 868 "/usr/include/stdio.h" 3 4
}
# 25 "/usr/include/malloc.h" 2 3 4
# 35 "/usr/include/malloc.h" 3 4
extern "C" {


extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;


extern void *calloc (size_t __nmemb, size_t __size)
throw () __attribute__ ((__malloc__)) ;






extern void *realloc (void *__ptr, size_t __size)
throw () __attribute__ ((__warn_unused_result__));






extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
throw () __attribute__ ((__warn_unused_result__));


extern void free (void *__ptr) throw ();


extern void *memalign (size_t __alignment, size_t __size)
throw () __attribute__ ((__malloc__)) ;


extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;



extern void *pvalloc (size_t __size) throw () __attribute__ ((__malloc__)) ;



extern void *(*__morecore) (ptrdiff_t __size);


extern void *__default_morecore (ptrdiff_t __size)
throw () __attribute__ ((__malloc__));



struct mallinfo
{
  int arena;
  int ordblks;
  int smblks;
  int hblks;
  int hblkhd;
  int usmblks;
  int fsmblks;
  int uordblks;
  int fordblks;
  int keepcost;
};


extern struct mallinfo mallinfo (void) throw ();
# 126 "/usr/include/malloc.h" 3 4
extern int mallopt (int __param, int __val) throw ();



extern int malloc_trim (size_t __pad) throw ();



extern size_t malloc_usable_size (void *__ptr) throw ();


extern void malloc_stats (void) throw ();


extern int malloc_info (int __options, FILE *__fp) throw ();


extern void (*volatile __free_hook) (void *__ptr,
                                                   const void *)
__attribute__ ((__deprecated__));
extern void *(*volatile __malloc_hook)(size_t __size,
                                                     const void *)
__attribute__ ((__deprecated__));
extern void *(*volatile __realloc_hook)(void *__ptr,
                                                      size_t __size,
                                                      const void *)
__attribute__ ((__deprecated__));
extern void *(*volatile __memalign_hook)(size_t __alignment,
                                                       size_t __size,
                                                       const void *)
__attribute__ ((__deprecated__));
extern void (*volatile __after_morecore_hook) (void);


extern void __malloc_check_init (void) throw () __attribute__ ((__deprecated__));


}
# 12 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_file_linux.h" 2


# 13 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_file_linux.h"
struct file_list
{
    glob_t GlobData;

    size_t FileCount;
    u32 FileIndex;
    file_data *CurrentFile;
    char Path[255];
};




file_list *
abf_InitializeFileList(memory_arena *Memory, const char *Path)
{
    file_list *Result = (file_list*)abm_PushSize_(Memory, sizeof(file_list));

    const u32 WildCardSize = (255) + 10;
    char WildCard[WildCardSize];
    stbsp_snprintf(WildCard, WildCardSize, "%s/*.c*", Path);
    s32 ReturnC = glob(WildCard, 0, 0, &Result->GlobData);

    stbsp_snprintf(WildCard, WildCardSize, "%s/*.h*", Path);
    s32 ReturnH = glob(WildCard, 
# 37 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_file_linux.h" 3 4
                                (1 << 5)
# 37 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_file_linux.h"
                                           , 0, &Result->GlobData);


    if( (ReturnC == 0) || (ReturnH == 0))
    {
        Result->FileCount = Result->GlobData.gl_pathc;
    }
    else
    {
        Result->FileCount = 0;
    }

    Result->FileIndex = 0;
    return Result;
}

b8
abf_GetNextFile(file_list *FileList, file_data *FileDataOut)
{
    b8 Result = false;

    if(FileList->CurrentFile)
    {
        if(FileList->CurrentFile->FileData)
        {
            free(FileList->CurrentFile->FileData);
            FileList->CurrentFile->FileData = 0;
        }
    }

    if(FileList->FileIndex < FileList->GlobData.gl_pathc)
    {

        char* FileName = FileList->GlobData.gl_pathv[FileList->FileIndex];
        ++FileList->FileIndex;

        int FileHandle = open(FileName, 
# 73 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_file_linux.h" 3 4
                                       00
# 73 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_file_linux.h"
                                               );
        if(FileHandle != -1)
        {
            struct stat FileStatus;
            if(fstat(FileHandle, &FileStatus) != -1)
            {
                FileDataOut->Size = FileStatus.st_size;

                FileDataOut->FileData = (char *)malloc(FileDataOut->Size+1);
                FileDataOut->FileData[FileDataOut->Size] = 0;
                if(FileDataOut->FileData)
                {
                    u32 BytesToRead = FileDataOut->Size;
                    u8* NextByteLocation = (u8*)FileDataOut->FileData;
                    while (BytesToRead)
                    {
                        s32 BytesRead = read(FileHandle, NextByteLocation, BytesToRead);
                        if(BytesRead == -1)
                        {
                            free(FileDataOut->FileData);
                            FileDataOut->FileData= 0;
                            FileDataOut->Size = 0;
                            Result = false;
                            break;
                        }
                        else
                        {
                            BytesToRead -= (uint32_t)BytesRead;
                            NextByteLocation += BytesRead;
                            Result = true;
                        }
                    }
                    FileList->CurrentFile = FileDataOut;
                }
                else
                {
                    FileDataOut->Size = 0;
                    FileList->CurrentFile = 0;
                }

            }
            close(FileHandle);
        }
    }
    else
    {
        FileList->CurrentFile = {};
    }


    return Result;

}

void
abf_ReleaseFileList(file_list *FileList)
{
    if(FileList)
    {
        if(FileList->CurrentFile)
        {
            if(FileList->CurrentFile->FileData)
            {
                free(FileList->CurrentFile->FileData);
            }
        }

        globfree(&FileList->GlobData);
    }

}
# 37 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_file.h" 2
# 13 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp" 2


# 1 "/home/amos/prog/c/amos_libraries/preprocessor/ab_lexer.h" 1





# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 36 "/usr/include/c++/7/stdlib.h" 3
# 1 "/usr/include/c++/7/cstdlib" 1 3
# 39 "/usr/include/c++/7/cstdlib" 3
       
# 40 "/usr/include/c++/7/cstdlib" 3

# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++config.h" 1 3
# 229 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++config.h" 3

# 229 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 251 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 533 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++config.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/os_defines.h" 1 3
# 534 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++config.h" 2 3


# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/cpu_defines.h" 1 3
# 537 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++config.h" 2 3
# 42 "/usr/include/c++/7/cstdlib" 2 3
# 75 "/usr/include/c++/7/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 32 "/usr/include/stdlib.h" 2 3 4

extern "C" {





# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 58 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;



extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 140 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     throw () __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     throw () __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 232 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 274 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 316 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
# 401 "/usr/include/stdlib.h" 3 4
extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();



extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;






extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));



extern void free (void *__ptr) throw ();


# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 567 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 607 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));





extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 672 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
# 685 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 695 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 707 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 717 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 728 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 739 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 749 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 759 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 771 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 781 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 797 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;
# 869 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();







extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 954 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
# 1016 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1017 "/usr/include/stdlib.h" 2 3 4
# 1026 "/usr/include/stdlib.h" 3 4
}
# 76 "/usr/include/c++/7/cstdlib" 2 3

# 1 "/usr/include/c++/7/bits/std_abs.h" 1 3
# 33 "/usr/include/c++/7/bits/std_abs.h" 3
       
# 34 "/usr/include/c++/7/bits/std_abs.h" 3
# 46 "/usr/include/c++/7/bits/std_abs.h" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }







  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }
# 106 "/usr/include/c++/7/bits/std_abs.h" 3

}
}
# 78 "/usr/include/c++/7/cstdlib" 2 3
# 121 "/usr/include/c++/7/cstdlib" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;

  using ::aligned_alloc;

  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }




}
# 195 "/usr/include/c++/7/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 227 "/usr/include/c++/7/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 37 "/usr/include/c++/7/stdlib.h" 2 3

using std::abort;
using std::atexit;
using std::exit;


  using std::at_quick_exit;


  using std::quick_exit;




using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 7 "/home/amos/prog/c/amos_libraries/preprocessor/ab_lexer.h" 2

# 1 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_string.h" 1
# 9 "/home/amos/prog/c/amos_libraries/preprocessor/ab_lexer.h" 2
# 1 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_file.h" 1
# 36 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_file.h"
# 1 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_file_linux.h" 1
# 37 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_file.h" 2
# 10 "/home/amos/prog/c/amos_libraries/preprocessor/ab_lexer.h" 2


# 11 "/home/amos/prog/c/amos_libraries/preprocessor/ab_lexer.h"
enum token_type
{
    TOKEN_Unknown,

    TOKEN_OpenParen,
    TOKEN_CloseParen,
    TOKEN_Colon,
    TOKEN_Semicolon,
    TOKEN_Comma,
    TOKEN_Asterisk,
    TOKEN_OpenBracket,
    TOKEN_CloseBracket,
    TOKEN_OpenBrace,
    TOKEN_CloseBrace,
    TOKEN_Dollar,
    TOKEN_Backslash,
    TOKEN_Foreslash,
    TOKEN_Ampersand,
    TOKEN_Pound,

    TOKEN_String,
    TOKEN_Identifier,
    TOKEN_Number,

    TOKEN_EndOfStream,

    TOKEN_Count
};

struct token
{
    token_type Type;
    abs_stringptr Text;
};

struct lexer
{
    char *At;
    s32 NumCurrentlyOpenBraces;
    s32 LineNumber;
};

void
abl_InitLexer(lexer *Lexer, file_data *File);

token
abl_GetToken(lexer *Lexer);

token
abl_PeekToken(lexer *Lexer);

s32
abl_TokenToS32(token Token);

b8
abl_TokenEquals(token Token, abs_stringptr Match);

b8
abl_TokensEquals(token A, token B);





void
abl_InitLexer(lexer *Lexer, file_data *File)
{
    Lexer->At = File->FileData;
    Lexer->NumCurrentlyOpenBraces = 0;
    Lexer->LineNumber = 0;
}

s32
abl_TokenToS32(token Token)
{
    s32 Value = 0;
    if(Token.Type == TOKEN_Number)
    {
        Value = atoi(Token.Text.String);
# 98 "/home/amos/prog/c/amos_libraries/preprocessor/ab_lexer.h"
    }

    return Value;
}

b8
abl_TokenEquals(token Token, abs_stringptr Match)
{
    b8 Result = abs_AreStringsEqual(Token.Text, Match);

    return Result;
}

b8
abl_TokensEquals(token A, token B)
{
    b8 isMatch = abs_AreStringsEqual(A.Text, B.Text);

    return isMatch;
}

inline b8
abl_IsEndOfLine(char C)
{
    b8 Result = ((C == '\n') || (C == '\r'));

    return Result;
}

inline b8
abl_IsWhitespace(char C)
{
    b8 Result = ((C == ' ') ||
                 (C == '\f') ||
                 (C == '\t') ||
                 (C == '\v')
                 );

    return Result;
}

inline b8
abl_IsAlpha(char C)
{
    b8 Result = ((C >= 'a' && C <= 'z') ||
                 (C >= 'A' && C <= 'Z') ||
                 (C == '_'));

    return Result;
}

inline b8
abl_IsNumeric(char C)
{
    b8 Result = ((C >= '0') && (C <= '9'));

    return Result;
}

void
abl_RemoveIgnorables(lexer *Tokenizer)
{
    for(;;)
    {
        if(abl_IsWhitespace(Tokenizer->At[0]))
        {
            ++Tokenizer->At;
        }
        else if (abl_IsEndOfLine(Tokenizer->At[0]))
        {
            ++Tokenizer->At;
            ++Tokenizer->LineNumber;
        }
        else if ((Tokenizer->At[0] == '/') &&
                 (Tokenizer->At[1] == '/'))
        {
            Tokenizer->At += 2;
            while(Tokenizer->At[0] &&
                  !abl_IsEndOfLine(Tokenizer->At[0]))
            {
                ++Tokenizer->At;
            }
        }
        else if((Tokenizer->At[0] == '/') &&
                (Tokenizer->At[1] == '*'))
        {
            Tokenizer->At += 2;
            while(Tokenizer->At[0] &&
                  (Tokenizer->At[0] == '*') &&
                  (Tokenizer->At[1] == '/'))
            {

                ++Tokenizer->At;
                if (abl_IsEndOfLine(Tokenizer->At[0]))
                {
                    ++Tokenizer->LineNumber;
                }

            }

            if(Tokenizer->At[0] == '*')
            {
                Tokenizer->At += 2;
            }
        }
        else
        {
            break;
        }
    }
}

token
abl_GetToken(lexer *Tokenizer)
{
    abl_RemoveIgnorables(Tokenizer);

    token Token = {};
    Token.Text = Tokenizer->At;
    Token.Text.Length = 1;
    char C = Tokenizer->At[0];
    ++Tokenizer->At;
    switch(C)
    {
        case '\0':
        {Token.Type = TOKEN_EndOfStream;} break;

        case '(':
        {Token.Type = TOKEN_OpenParen;} break;

        case ')':
        {Token.Type = TOKEN_CloseParen;} break;

        case '[':
        {Token.Type = TOKEN_OpenBracket;} break;

        case ']':
        {Token.Type = TOKEN_CloseBracket;} break;

        case '{':
        {Token.Type = TOKEN_OpenBrace; ++Tokenizer->NumCurrentlyOpenBraces;} break;

        case '}':
        {Token.Type = TOKEN_CloseBrace; --Tokenizer->NumCurrentlyOpenBraces;} break;

        case ':':
        {Token.Type = TOKEN_Colon;} break;

        case ';':
        {Token.Type = TOKEN_Semicolon;} break;

        case ',':
        {Token.Type = TOKEN_Comma;} break;

        case '$':
        {Token.Type = TOKEN_Dollar;} break;

        case '*':
        {Token.Type = TOKEN_Asterisk;} break;

        case '\\':
        {Token.Type = TOKEN_Backslash;} break;

        case '/':
        {Token.Type = TOKEN_Foreslash;} break;

        case '&':
        {Token.Type = TOKEN_Ampersand;} break;

        case '#':
        {Token.Type = TOKEN_Pound;} break;

        case '"':
        {
            Token.Type = TOKEN_String;
            Token.Text.String = Tokenizer->At;
            while(Tokenizer->At[0] &&
                  (Tokenizer->At[0] != '"'))
            {
                if((Tokenizer->At[0] == '\\') &&
                   (Tokenizer->At[1]))
                {
                    ++Tokenizer->At;
                }
                ++Tokenizer->At;
            }

            Token.Text.Length = (u32)(Tokenizer->At - Token.Text);
            if(Tokenizer->At[0] == '"')
            {
                ++Tokenizer->At;
            }
        } break;

        default:
        {
            if(abl_IsAlpha(C))
            {
                Token.Type = TOKEN_Identifier;
                while(abl_IsAlpha(Tokenizer->At[0]) ||
                      abl_IsNumeric(Tokenizer->At[0]))
                {
                    ++Tokenizer->At;
                }

                Token.Text.Length = (u32)(Tokenizer->At - Token.Text);
            }
            else if(abl_IsNumeric(C))
            {



                Token.Type = TOKEN_Number;
                while(abl_IsAlpha(Tokenizer->At[0]) ||
                      abl_IsNumeric(Tokenizer->At[0]) ||
                      (Tokenizer->At[0] == '.'))
                {
                    ++Tokenizer->At;
                }

                Token.Text.Length = (u32)(Tokenizer->At - Token.Text);
            }
            else
            {
                Token.Type = TOKEN_Unknown;
            }
        } break;
    }

    return Token;
}


token
abl_PeekToken(lexer *Lexer)
{
    char *Start = Lexer->At;
    token Token = abl_GetToken(Lexer);
    Lexer->At = Start;

    return Token;
}
# 16 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp" 2


# 1 "/home/amos/prog/c/amos_libraries/preprocessor/ab_parser.h" 1





# 1 "/home/amos/prog/c/amos_libraries/preprocessor/ab_lexer.h" 1
# 7 "/home/amos/prog/c/amos_libraries/preprocessor/ab_parser.h" 2
# 30 "/home/amos/prog/c/amos_libraries/preprocessor/ab_parser.h"
struct tag
{
    abs_stringptr Name;
    abs_stringptr Option;

    tag *Next;
    tag *Prev;
};

enum custom_type
{
    CT_None,
    CT_Struct,
    CT_Union,
    CT_Class,
    CT_Enum,
};

struct term_typeexpr
{
    abs_stringptr Type;
    abs_stringptr Name;

    b8 isPtr;
    b8 isReference;
    b8 isConst;
    b8 isArray;
    s32 ArrayLength;
    custom_type CustomType;

    term_typeexpr *Next;
    term_typeexpr *Prev;
};

struct term_definedfunction
{
    abs_stringptr Define;
    abs_stringptr Name;

    term_definedfunction *Next;
    term_definedfunction *Prev;
};

struct term_statemachine
{
    abs_stringptr Function;
    abs_stringptr Type;
    abs_stringptr Cmd;

    term_typeexpr TypeListSentinal;

    term_statemachine *Next;
    term_statemachine *Prev;
};

struct term_structitem
{
    term_typeexpr *Type;
    tag TagListSentinal;

    term_structitem *Next;
    term_structitem *Prev;
};

struct term_struct
{
    abs_stringptr Name;
    tag TagListSentinal;
    term_structitem ItemListSentinal;
    u32 ItemCount;

    term_struct *Next;
    term_struct *Prev;
};

struct term_enumitem
{
    abs_stringptr Name;
    tag TagListSentinal;

    term_enumitem *Next;
    term_enumitem *Prev;
};

struct term_enum
{
    abs_stringptr Name;
    tag TagListSentinal;
    term_enumitem ItemListSentinal;
    u32 ItemCount;

    term_enum *Next;
    term_enum *Prev;
};

struct term_function
{
    abs_stringptr Name;
    tag TagListSentinal;
    term_typeexpr TypeListSentinal;
    u32 TypeCount;

    term_function *Next;
    term_function *Prev;
};

struct term_statefunction
{

    term_statefunction *Next;
    term_statefunction *Prev;
};

struct parser
{
    memory_arena *Memory;

    term_struct StructListSentinal;
    term_enum EnumListSentinal;
    term_function FunctionListSentinal;
    term_statemachine StateMachineListSentinal;
    term_definedfunction DefinedFunctionListSentinal;
};

struct output_data
{
    char OutputString[(1024ULL * (200))];
    size_t Used;

    output_data *Next;
};

tag ParseTag(lexer *Lexer, parser *Parser);





b8
RequireToken(lexer *Lexer, token_type Type)
{
    token Token = abl_GetToken(Lexer);
    b8 Result = (Token.Type == Type);

    return Result;
}

b8
OptionalToken(lexer *Lexer, token_type Type)
{
    token Token = abl_PeekToken(Lexer);
    b8 Result = (Token.Type == Type);

    if(Result)
    {
        abl_GetToken(Lexer);
    }
    return Result;
}

b8
NextTokenEquals(lexer *Lexer, abs_stringptr TokenValue)
{
    b8 Result = false;

    token Token = abl_PeekToken(Lexer);
    if(abl_TokenEquals(Token, TokenValue))
    {
        abl_GetToken(Lexer);
        Result = true;
    }

    return Result;
}

term_enumitem *
ParseEnumitem(lexer *Lexer, parser *Parser)
{
    term_enumitem *EnumName = 0;
    tag TagList = {};
    { TagList.Next = &TagList; TagList.Prev = &TagList; };
    token Token = abl_GetToken(Lexer);
    if(abl_TokenEquals(Token, "TAG"))
    {
        TagList = ParseTag(Lexer,Parser);
        Token = abl_GetToken(Lexer);
    }

    if(Token.Type == TOKEN_Identifier)
    {
        EnumName = (term_enumitem*)abm_PushSize_(Parser->Memory, sizeof(term_enumitem));
        { EnumName->TagListSentinal.Next = &EnumName->TagListSentinal; EnumName->TagListSentinal.Prev = &EnumName->TagListSentinal; };
        { TagList.Prev->Next = &EnumName->TagListSentinal; TagList.Next->Prev = EnumName->TagListSentinal.Prev; EnumName->TagListSentinal.Prev->Next = TagList.Next; EnumName->TagListSentinal.Prev = TagList.Prev; };
        EnumName->Name = Token.Text;
    }

    return EnumName;
}

term_typeexpr *
ParseType(lexer *Lexer, parser *Parser)
{
    term_typeexpr *Expr = (term_typeexpr*)abm_PushSize_(Parser->Memory, sizeof(term_typeexpr));
    token Token;

    if(NextTokenEquals(Lexer, "const"))
    {
        Expr->isConst = true;
    }

    Token = abl_GetToken(Lexer);
    if(Token.Type == TOKEN_Identifier)
    {
        Expr->Type = Token.Text;
    }
    else
    {

    }

    if(NextTokenEquals(Lexer, "const"))
    {
        Expr->isConst = true;
    }

    if(OptionalToken(Lexer, TOKEN_Asterisk))
    {
        Expr->isPtr = true;
    }
    else if(OptionalToken(Lexer, TOKEN_Ampersand))
    {
        Expr->isReference = true;
    }

    return Expr;
}

term_typeexpr *
ParseTypeExpr(lexer *Lexer, parser *Parser)
{
    term_typeexpr *Expr = ParseType(Lexer, Parser);
    token Token = abl_GetToken(Lexer);

    if(Expr)
    {
        if(Token.Type == TOKEN_Identifier)
        {
            Expr->Name = Token.Text;
        }
        else
        {

        }

        if(OptionalToken(Lexer, TOKEN_OpenBracket))
        {
            Token = abl_GetToken(Lexer);
            Expr->isArray = true;
            Expr->ArrayLength = abl_TokenToS32(Token);
            if(!RequireToken(Lexer, TOKEN_CloseBracket))
            {

            }
        }
    }

    return Expr;
}

term_structitem *
ParseStructItem(lexer *Lexer, parser *Parser)
{
    term_structitem *StructItem = 0;
    tag TagList = {};
    { TagList.Next = &TagList; TagList.Prev = &TagList; };
    if(NextTokenEquals(Lexer, "TAG"))
    {
        TagList = ParseTag(Lexer, Parser);
    }

    term_typeexpr *StructItemType = ParseTypeExpr(Lexer, Parser);
    if(StructItemType)
    {
        StructItem = (term_structitem*)abm_PushSize_(Parser->Memory, sizeof(term_structitem));
        { StructItem->TagListSentinal.Next = &StructItem->TagListSentinal; StructItem->TagListSentinal.Prev = &StructItem->TagListSentinal; };
        { TagList.Prev->Next = &StructItem->TagListSentinal; TagList.Next->Prev = StructItem->TagListSentinal.Prev; StructItem->TagListSentinal.Prev->Next = TagList.Next; StructItem->TagListSentinal.Prev = TagList.Prev; };
        StructItem->Type = StructItemType;
        if(!RequireToken(Lexer, TOKEN_Semicolon))
        {

        }
    }

    return StructItem;
}

term_enum *
ParseEnumClass(lexer *Lexer, parser *Parser)
{
    term_enum *NewEnum = 0;
    token Token = abl_GetToken(Lexer);

    if(Token.Type == TOKEN_Identifier)
    {
        NewEnum = (term_enum*)abm_PushSize_(Parser->Memory, sizeof(term_enum));
        { NewEnum->TagListSentinal.Next = &NewEnum->TagListSentinal; NewEnum->TagListSentinal.Prev = &NewEnum->TagListSentinal; };
        { NewEnum->ItemListSentinal.Next = &NewEnum->ItemListSentinal; NewEnum->ItemListSentinal.Prev = &NewEnum->ItemListSentinal; };

        NewEnum->Name = Token.Text;

        if(RequireToken(Lexer, TOKEN_OpenBrace))
        {
            while(abl_PeekToken(Lexer).Type != TOKEN_CloseBrace)
            {
                term_enumitem *EnumName = ParseEnumitem(Lexer, Parser);
                if(EnumName)
                {
                    { EnumName->Next = &NewEnum->ItemListSentinal; EnumName->Prev = NewEnum->ItemListSentinal.Prev; NewEnum->ItemListSentinal.Prev->Next = EnumName; NewEnum->ItemListSentinal.Prev = EnumName; };
                    ++NewEnum->ItemCount;
                }
                OptionalToken(Lexer, TOKEN_Comma);
            }
            if(!RequireToken(Lexer, TOKEN_Semicolon))
            {

            }
        }
    }

    return NewEnum;
}

term_struct *
ParseStruct(lexer *Lexer, parser *Parser)
{
    term_struct *NewStruct = 0;
    token Token = abl_GetToken(Lexer);

    if(Token.Type == TOKEN_Identifier)
    {
        NewStruct = (term_struct*)abm_PushSize_(Parser->Memory, sizeof(term_struct));
        { NewStruct->TagListSentinal.Next = &NewStruct->TagListSentinal; NewStruct->TagListSentinal.Prev = &NewStruct->TagListSentinal; };
        { NewStruct->ItemListSentinal.Next = &NewStruct->ItemListSentinal; NewStruct->ItemListSentinal.Prev = &NewStruct->ItemListSentinal; };
        NewStruct->Name = Token.Text;

        if(RequireToken(Lexer, TOKEN_OpenBrace))
        {
            while(abl_PeekToken(Lexer).Type != TOKEN_CloseBrace)
            {
                term_structitem *NewItem = ParseStructItem(Lexer, Parser);
                if(NewItem)
                {
                    { NewItem->Next = &NewStruct->ItemListSentinal; NewItem->Prev = NewStruct->ItemListSentinal.Prev; NewStruct->ItemListSentinal.Prev->Next = NewItem; NewStruct->ItemListSentinal.Prev = NewItem; };
                }
            }
            if(!RequireToken(Lexer, TOKEN_Semicolon))
            {

            }
        }
    }

    return NewStruct;
}

term_function *
ParseFunction(lexer *Lexer, parser *Parser)
{
    return 0;
}

tag
ParseTag(lexer *Lexer, parser *Parser)
{
    tag TagList = {};
    { TagList.Next = &TagList; TagList.Prev = &TagList; };

    if(RequireToken(Lexer, TOKEN_OpenParen))
    {
        token Token = abl_GetToken(Lexer);
        while(Token.Type != TOKEN_CloseParen)
        {
            if(Token.Type == TOKEN_Identifier)
            {
                tag *NewTag = (tag*)abm_PushSize_(Parser->Memory, sizeof(tag));
                NewTag->Name = Token.Text;

                if(OptionalToken(Lexer, TOKEN_Colon))
                {
                    token Token = abl_GetToken(Lexer);
                    if(Token.Type == TOKEN_String ||
                       Token.Type == TOKEN_Identifier)
                    {
                        NewTag->Option = Token.Text;
                    }
                }

                OptionalToken(Lexer, TOKEN_Comma);
                { NewTag->Next = &TagList; NewTag->Prev = TagList.Prev; TagList.Prev->Next = NewTag; TagList.Prev = NewTag; };
            }

            Token = abl_GetToken(Lexer);
        }

        OptionalToken(Lexer, TOKEN_Semicolon);
        OptionalToken(Lexer, TOKEN_Comma);
    }

    return TagList;
}

void
ParseTaggedExpr(lexer *Lexer, parser *Parser, token Token)
{
    tag TagList = ParseTag(Lexer, Parser);

    if(NextTokenEquals(Lexer, "struct") || NextTokenEquals(Lexer, "union"))
    {
        term_struct *NewStruct = ParseStruct(Lexer, Parser);
        if(NewStruct)
        {
            { TagList.Prev->Next = &NewStruct->TagListSentinal; TagList.Next->Prev = NewStruct->TagListSentinal.Prev; NewStruct->TagListSentinal.Prev->Next = TagList.Next; NewStruct->TagListSentinal.Prev = TagList.Prev; };
            { NewStruct->Next = &Parser->StructListSentinal; NewStruct->Prev = Parser->StructListSentinal.Prev; Parser->StructListSentinal.Prev->Next = NewStruct; Parser->StructListSentinal.Prev = NewStruct; };
        }
    }
    else if(NextTokenEquals(Lexer, "enum") && NextTokenEquals(Lexer, "class"))
    {
        term_enum *NewEnum = ParseEnumClass(Lexer, Parser);
        if(NewEnum)
        {
            { TagList.Prev->Next = &NewEnum->TagListSentinal; TagList.Next->Prev = NewEnum->TagListSentinal.Prev; NewEnum->TagListSentinal.Prev->Next = TagList.Next; NewEnum->TagListSentinal.Prev = TagList.Prev; };
            { NewEnum->Next = &Parser->EnumListSentinal; NewEnum->Prev = Parser->EnumListSentinal.Prev; Parser->EnumListSentinal.Prev->Next = NewEnum; Parser->EnumListSentinal.Prev = NewEnum; };
        }
    }
    else
    {

        term_function *NewFunc = ParseFunction(Lexer, Parser);
        if(NewFunc)
        {
            { TagList.Prev->Next = &NewFunc->TagListSentinal; TagList.Next->Prev = NewFunc->TagListSentinal.Prev; NewFunc->TagListSentinal.Prev->Next = TagList.Next; NewFunc->TagListSentinal.Prev = TagList.Prev; };
            { NewFunc->Next = &Parser->FunctionListSentinal; NewFunc->Prev = Parser->FunctionListSentinal.Prev; Parser->FunctionListSentinal.Prev->Next = NewFunc; Parser->FunctionListSentinal.Prev = NewFunc; };
        }
    }


}

void
ParseStateMachineDef(lexer *Lexer, parser *Parser, token Token)
{
    if(RequireToken(Lexer, TOKEN_OpenParen))
    {
        token Token = abl_GetToken(Lexer);
        if(Token.Type == TOKEN_Identifier)
        {
            term_statemachine *StateMachine = (term_statemachine*)abm_PushSize_(Parser->Memory, sizeof(term_statemachine));
            { StateMachine->TypeListSentinal.Next = &StateMachine->TypeListSentinal; StateMachine->TypeListSentinal.Prev = &StateMachine->TypeListSentinal; };
            StateMachine->Function = Token.Text;
            RequireToken(Lexer, TOKEN_Comma);
            Token = abl_GetToken(Lexer);
            StateMachine->Type = Token.Text;

            RequireToken(Lexer,TOKEN_Comma);
            Token = abl_GetToken(Lexer);
            StateMachine->Cmd = Token.Text;

            while(OptionalToken(Lexer, TOKEN_Comma))
            {
                if(abl_PeekToken(Lexer).Type == TOKEN_Identifier)
                {
                    custom_type CustomType = CT_None;

                    if(NextTokenEquals(Lexer, "STRUCT"))
                    {
                        CustomType = CT_Struct;
                    }
                    else if(NextTokenEquals(Lexer, "ENUM"))
                    {
                        CustomType = CT_Enum;
                    }
                    else if(NextTokenEquals(Lexer, "UNION"))
                    {
                        CustomType = CT_Union;
                    }
                    else if(NextTokenEquals(Lexer, "CLASS"))
                    {
                        CustomType = CT_Class;
                    }

                    term_typeexpr *Type = ParseTypeExpr(Lexer, Parser);
                    Type->CustomType = CustomType;

                    { Type->Next = &StateMachine->TypeListSentinal; Type->Prev = StateMachine->TypeListSentinal.Prev; StateMachine->TypeListSentinal.Prev->Next = Type; StateMachine->TypeListSentinal.Prev = Type; };
                }
            }

            if (!RequireToken(Lexer, TOKEN_CloseParen))
            {

            }

            OptionalToken(Lexer, TOKEN_Semicolon);
            { StateMachine->Next = &Parser->StateMachineListSentinal; StateMachine->Prev = Parser->StateMachineListSentinal.Prev; Parser->StateMachineListSentinal.Prev->Next = StateMachine; Parser->StateMachineListSentinal.Prev = StateMachine; };
        }
    }
}

void
ParseDefinedFunction(lexer *Lexer, parser *Parser, token Token)
{
    term_definedfunction NewFunction = {};
    b8 isGoodFunction = false;

    NewFunction.Define = Token.Text;
    if(RequireToken(Lexer, TOKEN_OpenParen))
    {
        token Token = abl_GetToken(Lexer);
        if(Token.Type == TOKEN_Identifier &&
           RequireToken(Lexer, TOKEN_CloseParen))
        {
            NewFunction.Name = Token.Text;
            isGoodFunction = true;
        }
        else
        {

        }

    }

    if(isGoodFunction)
    {
        term_definedfunction *Function = (term_definedfunction*)abm_PushSize_(Parser->Memory, sizeof(term_definedfunction));
        *Function = NewFunction;
        { Function->Next = &Parser->DefinedFunctionListSentinal; Function->Prev = Parser->DefinedFunctionListSentinal.Prev; Parser->DefinedFunctionListSentinal.Prev->Next = Function; Parser->DefinedFunctionListSentinal.Prev = Function; };
    }
}

inline b8
isDefineFunction(lexer *Lexer, token ThisToken)
{
    char *Start = Lexer->At;

    b8 Result =
        ((ThisToken.Type == TOKEN_Identifier) &&
         (abl_GetToken(Lexer).Type == TOKEN_OpenParen) &&
         (abl_GetToken(Lexer).Type == TOKEN_Identifier) &&
         (abl_GetToken(Lexer).Type == TOKEN_CloseParen));

    Lexer->At = Start;

    return Result;
}

void
ParseExpr(lexer *Lexer, parser *Parser)
{
    b8 isFinished = false;
    while(!isFinished)
    {
        token Token = abl_GetToken(Lexer);
        switch(Token.Type)
        {
            case TOKEN_Identifier:
            {
                if(abl_TokenEquals(Token, "TAG"))
                {
                    ParseTaggedExpr(Lexer, Parser, Token);
                }
                else if(abl_TokenEquals(Token, "STATEMACHINE"))
                {
                    ParseStateMachineDef(Lexer, Parser, Token);
                }
                else if(isDefineFunction(Lexer, Token))
                {
                    ParseDefinedFunction(Lexer, Parser, Token);
                }

            }break;

            case TOKEN_EndOfStream:
            {
                isFinished = true;
            }break;

            case TOKEN_Unknown:
            default:
            {}break;
        }
    }
}

parser *
ParseInit(memory_arena *Memory)
{
    parser *Parser = (parser*)abm_PushSize_(Memory, sizeof(parser));
    Parser->Memory = Memory;
    { Parser->StructListSentinal.Next = &Parser->StructListSentinal; Parser->StructListSentinal.Prev = &Parser->StructListSentinal; };
    { Parser->EnumListSentinal.Next = &Parser->EnumListSentinal; Parser->EnumListSentinal.Prev = &Parser->EnumListSentinal; };
    { Parser->FunctionListSentinal.Next = &Parser->FunctionListSentinal; Parser->FunctionListSentinal.Prev = &Parser->FunctionListSentinal; };
    { Parser->StateMachineListSentinal.Next = &Parser->StateMachineListSentinal; Parser->StateMachineListSentinal.Prev = &Parser->StateMachineListSentinal; };
    { Parser->DefinedFunctionListSentinal.Next = &Parser->DefinedFunctionListSentinal; Parser->DefinedFunctionListSentinal.Prev = &Parser->DefinedFunctionListSentinal; };

    return Parser;
}
# 19 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp" 2


# 1 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 1
# 203 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 204 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 2
# 239 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
static signed int stbsp__real_to_str(char const **start, unsigned int *len, char *out, signed int *decimal_pos, double value, unsigned int frac_digits);
static signed int stbsp__real_to_parts(signed long long *bits, signed int *expo, double value);



static char stbsp__period = '.';
static char stbsp__comma = ',';
static struct
{
    short temp;
    char pair[201];
} stbsp__digitpair =
{
    0,
    "00010203040506070809101112131415161718192021222324"
        "25262728293031323334353637383940414243444546474849"
        "50515253545556575859606162636465666768697071727374"
        "75767778798081828384858687888990919293949596979899"
};

extern "C" void stbsp_set_separators(char pcomma, char pperiod)
{
    stbsp__period = pperiod;
    stbsp__comma = pcomma;
}
# 279 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
static void stbsp__lead_sign(unsigned int fl, char *sign)
{
    sign[0] = 0;
    if (fl & 128) {
        sign[0] = 1;
        sign[1] = '-';
    } else if (fl & 4) {
        sign[0] = 1;
        sign[1] = ' ';
    } else if (fl & 2) {
        sign[0] = 1;
        sign[1] = '+';
    }
}

extern "C" int stbsp_vsprintfcb(STBSP_SPRINTFCB *callback, void *user, char *buf, char const *fmt, va_list va)
{
    static char hex[] = "0123456789abcdefxp";
    static char hexu[] = "0123456789ABCDEFXP";
    char *bf;
    char const *f;
    int tlen = 0;

    bf = buf;
    f = fmt;
    for (;;) {
        signed int fw, pr, tz;
        unsigned int fl;
# 337 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
        for (;;) {
            while (((unsigned long long)f) & 3) {
                schk1:
                if (f[0] == '%')
                    goto scandd;
                schk2:
                if (f[0] == 0)
                    goto endfmt;
                { if (callback) { { int len = (int)(bf - buf); if ((len + (1)) >= 512) { tlen += len; if (0 == (bf = buf = callback(buf, user, len))) goto done; } }; } };
                *bf++ = f[0];
                ++f;
            }
            for (;;) {



                unsigned int v, c;
                v = *(unsigned int *)f;
                c = (~v) & 0x80808080;
                if (((v ^ 0x25252525) - 0x01010101) & c)
                    goto schk1;
                if ((v - 0x01010101) & c)
                    goto schk2;
                if (callback)
                    if ((512 - (int)(bf - buf)) < 4)
                    goto schk1;
# 371 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                {
                    *(unsigned int *)bf = v;
                }
                bf += 4;
                f += 4;
            }
        }
        scandd:

        ++f;


        fw = 0;
        pr = -1;
        fl = 0;
        tz = 0;


        for (;;) {
            switch (f[0]) {

                case '-':
                fl |= 1;
                ++f;
                continue;

                case '+':
                fl |= 2;
                ++f;
                continue;

                case ' ':
                fl |= 4;
                ++f;
                continue;

                case '#':
                fl |= 8;
                ++f;
                continue;

                case '\'':
                fl |= 64;
                ++f;
                continue;

                case '$':
                if (fl & 256) {
                    if (fl & 2048) {
                        fl |= 4096;
                    } else {
                        fl |= 2048;
                    }
                } else {
                    fl |= 256;
                }
                ++f;
                continue;

                case '_':
                fl |= 1024;
                ++f;
                continue;

                case '0':
                fl |= 16;
                ++f;
                goto flags_done;
                default: goto flags_done;
            }
        }
        flags_done:


        if (f[0] == '*') {
            fw = 
# 446 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                __builtin_va_arg(
# 446 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                va
# 446 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                ,
# 446 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                unsigned int
# 446 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                )
# 446 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                                         ;
            ++f;
        } else {
            while ((f[0] >= '0') && (f[0] <= '9')) {
                fw = fw * 10 + f[0] - '0';
                f++;
            }
        }

        if (f[0] == '.') {
            ++f;
            if (f[0] == '*') {
                pr = 
# 458 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                    __builtin_va_arg(
# 458 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                    va
# 458 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                    ,
# 458 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                    unsigned int
# 458 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                    )
# 458 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                                             ;
                ++f;
            } else {
                pr = 0;
                while ((f[0] >= '0') && (f[0] <= '9')) {
                    pr = pr * 10 + f[0] - '0';
                    f++;
                }
            }
        }


        switch (f[0]) {

            case 'h':
            fl |= 512;
            ++f;
            if (f[0] == 'h')
                ++f;
            break;

            case 'l':
            fl |= ((sizeof(long) == 8) ? 32 : 0);
            ++f;
            if (f[0] == 'l') {
                fl |= 32;
                ++f;
            }
            break;

            case 'j':
            fl |= (sizeof(size_t) == 8) ? 32 : 0;
            ++f;
            break;

            case 'z':
            fl |= (sizeof(ptrdiff_t) == 8) ? 32 : 0;
            ++f;
            break;
            case 't':
            fl |= (sizeof(ptrdiff_t) == 8) ? 32 : 0;
            ++f;
            break;

            case 'I':
            if ((f[1] == '6') && (f[2] == '4')) {
                fl |= 32;
                f += 3;
            } else if ((f[1] == '3') && (f[2] == '2')) {
                f += 3;
            } else {
                fl |= ((sizeof(void *) == 8) ? 32 : 0);
                ++f;
            }
            break;
            default: break;
        }


        switch (f[0]) {

            char num[512];
            char lead[8];
            char tail[8];
            char *s;
            char const *h;
            unsigned int l, n, cs;
            unsigned long long n64;

            double fv;

            signed int dp;
            char const *sn;

            case 's':

            s = 
# 534 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
               __builtin_va_arg(
# 534 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
               va
# 534 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
               ,
# 534 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
               char *
# 534 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
               )
# 534 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                                 ;
            if (s == 0)
                s = (char *)"null";

            sn = s;
            for (;;) {
                if ((((unsigned long long)sn) & 3) == 0)
                    break;
                lchk:
                if (sn[0] == 0)
                    goto ld;
                ++sn;
            }
            n = 0xffffffff;
            if (pr >= 0) {
                n = (unsigned int)(sn - s);
                if (n >= (unsigned int)pr)
                    goto ld;
                n = ((unsigned int)(pr - n)) >> 2;
            }
            while (n) {
                unsigned int v = *(unsigned int *)sn;
                if ((v - 0x01010101) & (~v) & 0x80808080UL)
                    goto lchk;
                sn += 4;
                --n;
            }
            goto lchk;
            ld:

            l = (unsigned int)(sn - s);

            if (l > (unsigned int)pr)
                l = pr;
            lead[0] = 0;
            tail[0] = 0;
            pr = 0;
            dp = 0;
            cs = 0;

            goto scopy;

            case 'c':

            s = num + 512 - 1;
            *s = (char)
# 579 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                      __builtin_va_arg(
# 579 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                      va
# 579 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                      ,
# 579 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                      int
# 579 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                      )
# 579 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                                     ;
            l = 1;
            lead[0] = 0;
            tail[0] = 0;
            pr = 0;
            dp = 0;
            cs = 0;
            goto scopy;

            case 'n':
            {
                int *d = 
# 590 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                        __builtin_va_arg(
# 590 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                        va
# 590 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                        ,
# 590 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                        int *
# 590 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                        )
# 590 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                                         ;
                *d = tlen + (int)(bf - buf);
            } break;
# 612 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
            case 'A':
            case 'a':
            h = (f[0] == 'A') ? hexu : hex;
            fv = 
# 615 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                __builtin_va_arg(
# 615 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                va
# 615 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                ,
# 615 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                double
# 615 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                )
# 615 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                                  ;
            if (pr == -1)
                pr = 6;

            if (stbsp__real_to_parts((signed long long *)&n64, &dp, fv))
                fl |= 128;

            s = num + 64;

            stbsp__lead_sign(fl, lead);

            if (dp == -1023)
                dp = (n64) ? -1022 : 0;
            else
                n64 |= (((unsigned long long)1) << 52);
            n64 <<= (64 - 56);
            if (pr < 15)
                n64 += ((((unsigned long long)8) << 56) >> (pr * 4));






            lead[1 + lead[0]] = '0';
            lead[2 + lead[0]] = 'x';
            lead[0] += 2;

            *s++ = h[(n64 >> 60) & 15];
            n64 <<= 4;
            if (pr)
                *s++ = stbsp__period;
            sn = s;


            n = pr;
            if (n > 13)
                n = 13;
            if (pr > (signed int)n)
                tz = pr - n;
            pr = 0;
            while (n--) {
                *s++ = h[(n64 >> 60) & 15];
                n64 <<= 4;
            }


            tail[1] = h[17];
            if (dp < 0) {
                tail[2] = '-';
                dp = -dp;
            } else
                tail[2] = '+';
            n = (dp >= 1000) ? 6 : ((dp >= 100) ? 5 : ((dp >= 10) ? 4 : 3));
            tail[0] = (char)n;
            for (;;) {
                tail[n] = '0' + dp % 10;
                if (n <= 3)
                    break;
                --n;
                dp /= 10;
            }

            dp = (int)(s - sn);
            l = (int)(s - (num + 64));
            s = num + 64;
            cs = 1 + (3 << 24);
            goto scopy;

            case 'G':
            case 'g':
            h = (f[0] == 'G') ? hexu : hex;
            fv = 
# 687 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                __builtin_va_arg(
# 687 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                va
# 687 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                ,
# 687 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                double
# 687 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                )
# 687 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                                  ;
            if (pr == -1)
                pr = 6;
            else if (pr == 0)
                pr = 1;

            if (stbsp__real_to_str(&sn, &l, num, &dp, fv, (pr - 1) | 0x80000000))
                fl |= 128;


            n = pr;
            if (l > (unsigned int)pr)
                l = pr;
            while ((l > 1) && (pr) && (sn[l - 1] == '0')) {
                --pr;
                --l;
            }


            if ((dp <= -4) || (dp > (signed int)n)) {
                if (pr > (signed int)l)
                    pr = l - 1;
                else if (pr)
                    --pr;
                goto doexpfromg;
            }

            if (dp > 0) {
                pr = (dp < (signed int)l) ? l - dp : 0;
            } else {
                pr = -dp + ((pr > (signed int)l) ? (signed int) l : pr);
            }
            goto dofloatfromg;

            case 'E':
            case 'e':
            h = (f[0] == 'E') ? hexu : hex;
            fv = 
# 724 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                __builtin_va_arg(
# 724 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                va
# 724 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                ,
# 724 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                double
# 724 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                )
# 724 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                                  ;
            if (pr == -1)
                pr = 6;

            if (stbsp__real_to_str(&sn, &l, num, &dp, fv, pr | 0x80000000))
                fl |= 128;
            doexpfromg:
            tail[0] = 0;
            stbsp__lead_sign(fl, lead);
            if (dp == 0x7000) {
                s = (char *)sn;
                cs = 0;
                pr = 0;
                goto scopy;
            }
            s = num + 64;

            *s++ = sn[0];

            if (pr)
                *s++ = stbsp__period;


            if ((l - 1) > (unsigned int)pr)
                l = pr + 1;
            for (n = 1; n < l; n++)
                *s++ = sn[n];

            tz = pr - (l - 1);
            pr = 0;

            tail[1] = h[0xe];
            dp -= 1;
            if (dp < 0) {
                tail[2] = '-';
                dp = -dp;
            } else
                tail[2] = '+';



            n = (dp >= 100) ? 5 : 4;

            tail[0] = (char)n;
            for (;;) {
                tail[n] = '0' + dp % 10;
                if (n <= 3)
                    break;
                --n;
                dp /= 10;
            }
            cs = 1 + (3 << 24);
            goto flt_lead;

            case 'f':
            fv = 
# 779 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                __builtin_va_arg(
# 779 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                va
# 779 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                ,
# 779 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                double
# 779 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                )
# 779 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                                  ;
            doafloat:

            if (fl & 256) {
                double divisor;
                divisor = 1000.0f;
                if (fl & 2048)
                    divisor = 1024.0;
                while (fl < 0x4000000) {
                    if ((fv < divisor) && (fv > -divisor))
                        break;
                    fv /= divisor;
                    fl += 0x1000000;
                }
            }
            if (pr == -1)
                pr = 6;

            if (stbsp__real_to_str(&sn, &l, num, &dp, fv, pr))
                fl |= 128;
            dofloatfromg:
            tail[0] = 0;
            stbsp__lead_sign(fl, lead);
            if (dp == 0x7000) {
                s = (char *)sn;
                cs = 0;
                pr = 0;
                goto scopy;
            }
            s = num + 64;


            if (dp <= 0) {
                signed int i;

                *s++ = '0';
                if (pr)
                    *s++ = stbsp__period;
                n = -dp;
                if ((signed int)n > pr)
                    n = pr;
                i = n;
                while (i) {
                    if ((((unsigned long long)s) & 3) == 0)
                        break;
                    *s++ = '0';
                    --i;
                }
                while (i >= 4) {
                    *(unsigned int *)s = 0x30303030;
                    s += 4;
                    i -= 4;
                }
                while (i) {
                    *s++ = '0';
                    --i;
                }
                if ((signed int)(l + n) > pr)
                    l = pr - n;
                i = l;
                while (i) {
                    *s++ = *sn++;
                    --i;
                }
                tz = pr - (n + l);
                cs = 1 + (3 << 24);
            } else {
                cs = (fl & 64) ? ((600 - (unsigned int)dp) % 3) : 0;
                if ((unsigned int)dp >= l) {

                    n = 0;
                    for (;;) {
                        if ((fl & 64) && (++cs == 4)) {
                            cs = 0;
                            *s++ = stbsp__comma;
                        } else {
                            *s++ = sn[n];
                            ++n;
                            if (n >= l)
                                break;
                        }
                    }
                    if (n < (unsigned int)dp) {
                        n = dp - n;
                        if ((fl & 64) == 0) {
                            while (n) {
                                if ((((unsigned long long)s) & 3) == 0)
                                    break;
                                *s++ = '0';
                                --n;
                            }
                            while (n >= 4) {
                                *(unsigned int *)s = 0x30303030;
                                s += 4;
                                n -= 4;
                            }
                        }
                        while (n) {
                            if ((fl & 64) && (++cs == 4)) {
                                cs = 0;
                                *s++ = stbsp__comma;
                            } else {
                                *s++ = '0';
                                --n;
                            }
                        }
                    }
                    cs = (int)(s - (num + 64)) + (3 << 24);
                    if (pr) {
                        *s++ = stbsp__period;
                        tz = pr;
                    }
                } else {

                    n = 0;
                    for (;;) {
                        if ((fl & 64) && (++cs == 4)) {
                            cs = 0;
                            *s++ = stbsp__comma;
                        } else {
                            *s++ = sn[n];
                            ++n;
                            if (n >= (unsigned int)dp)
                                break;
                        }
                    }
                    cs = (int)(s - (num + 64)) + (3 << 24);
                    if (pr)
                        *s++ = stbsp__period;
                    if ((l - dp) > (unsigned int)pr)
                        l = pr + dp;
                    while (n < l) {
                        *s++ = sn[n];
                        ++n;
                    }
                    tz = pr - (l - dp);
                }
            }
            pr = 0;


            if (fl & 256) {
                char idx;
                idx = 1;
                if (fl & 1024)
                    idx = 0;
                tail[0] = idx;
                tail[1] = ' ';
                {
                    if (fl >> 24) {
                        if (fl & 2048)
                            tail[idx + 1] = "_KMGT"[fl >> 24];
                        else
                            tail[idx + 1] = "_kMGT"[fl >> 24];
                        idx++;

                        if (fl & 2048 && !(fl & 4096)) {
                            tail[idx + 1] = 'i';
                            idx++;
                        }
                        tail[0] = idx;
                    }
                }
            };

            flt_lead:

            l = (unsigned int)(s - (num + 64));
            s = num + 64;
            goto scopy;


            case 'B':
            case 'b':
            h = (f[0] == 'B') ? hexu : hex;
            lead[0] = 0;
            if (fl & 8) {
                lead[0] = 2;
                lead[1] = '0';
                lead[2] = h[0xb];
            }
            l = (8 << 4) | (1 << 8);
            goto radixnum;

            case 'o':
            h = hexu;
            lead[0] = 0;
            if (fl & 8) {
                lead[0] = 1;
                lead[1] = '0';
            }
            l = (3 << 4) | (3 << 8);
            goto radixnum;

            case 'p':
            fl |= (sizeof(void *) == 8) ? 32 : 0;
            pr = sizeof(void *) * 2;
            fl &= ~16;


            case 'X':
            case 'x':
            h = (f[0] == 'X') ? hexu : hex;
            l = (4 << 4) | (4 << 8);
            lead[0] = 0;
            if (fl & 8) {
                lead[0] = 2;
                lead[1] = '0';
                lead[2] = h[16];
            }
            radixnum:

            if (fl & 32)
                n64 = 
# 992 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                     __builtin_va_arg(
# 992 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                     va
# 992 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                     ,
# 992 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                     unsigned long long
# 992 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                     )
# 992 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                                              ;
            else
                n64 = 
# 994 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                     __builtin_va_arg(
# 994 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                     va
# 994 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                     ,
# 994 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                     unsigned int
# 994 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                     )
# 994 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                                              ;

            s = num + 512;
            dp = 0;

            tail[0] = 0;
            if (n64 == 0) {
                lead[0] = 0;
                if (pr == 0) {
                    l = 0;
                    cs = (((l >> 4) & 15)) << 24;
                    goto scopy;
                }
            }

            for (;;) {
                *--s = h[n64 & ((1 << (l >> 8)) - 1)];
                n64 >>= (l >> 8);
                if (!((n64) || ((signed int)((num + 512) - s) < pr)))
                    break;
                if (fl & 64) {
                    ++l;
                    if ((l & 15) == ((l >> 4) & 15)) {
                        l &= ~15;
                        *--s = stbsp__comma;
                    }
                }
            };

            cs = (unsigned int)((num + 512) - s) + ((((l >> 4) & 15)) << 24);

            l = (unsigned int)((num + 512) - s);

            goto scopy;

            case 'u':
            case 'i':
            case 'd':

            if (fl & 32) {
                signed long long i64 = 
# 1034 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                                  __builtin_va_arg(
# 1034 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                                  va
# 1034 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                                  ,
# 1034 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                                  signed long long
# 1034 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                                  )
# 1034 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                                                          ;
                n64 = (unsigned long long)i64;
                if ((f[0] != 'u') && (i64 < 0)) {
                    n64 = (unsigned long long)-i64;
                    fl |= 128;
                }
            } else {
                signed int i = 
# 1041 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                                __builtin_va_arg(
# 1041 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                                va
# 1041 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                                ,
# 1041 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                                signed int
# 1041 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
                                )
# 1041 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                                                        ;
                n64 = (unsigned int)i;
                if ((f[0] != 'u') && (i < 0)) {
                    n64 = (unsigned int)-i;
                    fl |= 128;
                }
            }


            if (fl & 256) {
                if (n64 < 1024)
                    pr = 0;
                else if (pr == -1)
                    pr = 1;
                fv = (double)(signed long long)n64;
                goto doafloat;
            }



            s = num + 512;
            l = 0;

            for (;;) {

                char *o = s - 8;
                if (n64 >= 100000000) {
                    n = (unsigned int)(n64 % 100000000);
                    n64 /= 100000000;
                } else {
                    n = (unsigned int)n64;
                    n64 = 0;
                }
                if ((fl & 64) == 0) {
                    do {
                        s -= 2;
                        *(unsigned short *)s = *(unsigned short *)&stbsp__digitpair.pair[(n % 100) * 2];
                        n /= 100;
                    } while (n);
                }
                while (n) {
                    if ((fl & 64) && (l++ == 3)) {
                        l = 0;
                        *--s = stbsp__comma;
                        --o;
                    } else {
                        *--s = (char)(n % 10) + '0';
                        n /= 10;
                    }
                }
                if (n64 == 0) {
                    if ((s[0] == '0') && (s != (num + 512)))
                        ++s;
                    break;
                }
                while (s != o)
                    if ((fl & 64) && (l++ == 3)) {
                    l = 0;
                    *--s = stbsp__comma;
                    --o;
                } else {
                    *--s = '0';
                }
            }

            tail[0] = 0;
            stbsp__lead_sign(fl, lead);


            l = (unsigned int)((num + 512) - s);
            if (l == 0) {
                *--s = '0';
                l = 1;
            }
            cs = l + (3 << 24);
            if (pr < 0)
                pr = 0;

            scopy:

            if (pr < (signed int)l)
                pr = l;
            n = pr + lead[0] + tail[0] + tz;
            if (fw < (signed int)n)
                fw = n;
            fw -= n;
            pr -= l;


            if ((fl & 1) == 0) {
                if (fl & 16)
                {
                    pr = (fw > pr) ? fw : pr;
                    fw = 0;
                } else {
                    fl &= ~64;
                }
            }


            if (fw + pr) {
                signed int i;
                unsigned int c;


                if ((fl & 1) == 0)
                    while (fw > 0) {
                    i = fw; if (callback) { int lg = 512 - (int)(bf - buf); if (i > lg) i = lg; };
                    fw -= i;
                    while (i) {
                        if ((((unsigned long long)bf) & 3) == 0)
                            break;
                        *bf++ = ' ';
                        --i;
                    }
                    while (i >= 4) {
                        *(unsigned int *)bf = 0x20202020;
                        bf += 4;
                        i -= 4;
                    }
                    while (i) {
                        *bf++ = ' ';
                        --i;
                    }
                    { if (callback) { { int len = (int)(bf - buf); if ((len + (1)) >= 512) { tlen += len; if (0 == (bf = buf = callback(buf, user, len))) goto done; } }; } };
                }


                sn = lead + 1;
                while (lead[0]) {
                    i = lead[0]; if (callback) { int lg = 512 - (int)(bf - buf); if (i > lg) i = lg; };
                    lead[0] -= (char)i;
                    while (i) {
                        *bf++ = *sn++;
                        --i;
                    }
                    { if (callback) { { int len = (int)(bf - buf); if ((len + (1)) >= 512) { tlen += len; if (0 == (bf = buf = callback(buf, user, len))) goto done; } }; } };
                }


                c = cs >> 24;
                cs &= 0xffffff;
                cs = (fl & 64) ? ((unsigned int)(c - ((pr + cs) % (c + 1)))) : 0;
                while (pr > 0) {
                    i = pr; if (callback) { int lg = 512 - (int)(bf - buf); if (i > lg) i = lg; };
                    pr -= i;
                    if ((fl & 64) == 0) {
                        while (i) {
                            if ((((unsigned long long)bf) & 3) == 0)
                                break;
                            *bf++ = '0';
                            --i;
                        }
                        while (i >= 4) {
                            *(unsigned int *)bf = 0x30303030;
                            bf += 4;
                            i -= 4;
                        }
                    }
                    while (i) {
                        if ((fl & 64) && (cs++ == c)) {
                            cs = 0;
                            *bf++ = stbsp__comma;
                        } else
                            *bf++ = '0';
                        --i;
                    }
                    { if (callback) { { int len = (int)(bf - buf); if ((len + (1)) >= 512) { tlen += len; if (0 == (bf = buf = callback(buf, user, len))) goto done; } }; } };
                }
            }


            sn = lead + 1;
            while (lead[0]) {
                signed int i;
                i = lead[0]; if (callback) { int lg = 512 - (int)(bf - buf); if (i > lg) i = lg; };
                lead[0] -= (char)i;
                while (i) {
                    *bf++ = *sn++;
                    --i;
                }
                { if (callback) { { int len = (int)(bf - buf); if ((len + (1)) >= 512) { tlen += len; if (0 == (bf = buf = callback(buf, user, len))) goto done; } }; } };
            }


            n = l;
            while (n) {
                signed int i;
                i = n; if (callback) { int lg = 512 - (int)(bf - buf); if (i > lg) i = lg; };
                n -= i;
                while (i >= 4) { *(unsigned int *)bf = *(unsigned int *)s; bf += 4; s += 4; i -= 4; }





                    while (i) {
                    *bf++ = *s++;
                    --i;
                }
                { if (callback) { { int len = (int)(bf - buf); if ((len + (1)) >= 512) { tlen += len; if (0 == (bf = buf = callback(buf, user, len))) goto done; } }; } };
            }


            while (tz) {
                signed int i;
                i = tz; if (callback) { int lg = 512 - (int)(bf - buf); if (i > lg) i = lg; };
                tz -= i;
                while (i) {
                    if ((((unsigned long long)bf) & 3) == 0)
                        break;
                    *bf++ = '0';
                    --i;
                }
                while (i >= 4) {
                    *(unsigned int *)bf = 0x30303030;
                    bf += 4;
                    i -= 4;
                }
                while (i) {
                    *bf++ = '0';
                    --i;
                }
                { if (callback) { { int len = (int)(bf - buf); if ((len + (1)) >= 512) { tlen += len; if (0 == (bf = buf = callback(buf, user, len))) goto done; } }; } };
            }


            sn = tail + 1;
            while (tail[0]) {
                signed int i;
                i = tail[0]; if (callback) { int lg = 512 - (int)(bf - buf); if (i > lg) i = lg; };
                tail[0] -= (char)i;
                while (i) {
                    *bf++ = *sn++;
                    --i;
                }
                { if (callback) { { int len = (int)(bf - buf); if ((len + (1)) >= 512) { tlen += len; if (0 == (bf = buf = callback(buf, user, len))) goto done; } }; } };
            }


            if (fl & 1)
                if (fw > 0) {
                while (fw) {
                    signed int i;
                    i = fw; if (callback) { int lg = 512 - (int)(bf - buf); if (i > lg) i = lg; };
                    fw -= i;
                    while (i) {
                        if ((((unsigned long long)bf) & 3) == 0)
                            break;
                        *bf++ = ' ';
                        --i;
                    }
                    while (i >= 4) {
                        *(unsigned int *)bf = 0x20202020;
                        bf += 4;
                        i -= 4;
                    }
                    while (i--)
                        *bf++ = ' ';
                    { if (callback) { { int len = (int)(bf - buf); if ((len + (1)) >= 512) { tlen += len; if (0 == (bf = buf = callback(buf, user, len))) goto done; } }; } };
                }
            }
            break;

            default:
            s = num + 512 - 1;
            *s = f[0];
            l = 1;
            fw = fl = 0;
            lead[0] = 0;
            tail[0] = 0;
            pr = 0;
            dp = 0;
            cs = 0;
            goto scopy;
        }
        ++f;
    }
    endfmt:

    if (!callback)
        *bf = 0;
    else
        { { int len = (int)(bf - buf); if ((len + (512 - 1)) >= 512) { tlen += len; if (0 == (bf = buf = callback(buf, user, len))) goto done; } }; };

    done:
    return tlen + (int)(bf - buf);
}
# 1349 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
extern "C" int stbsp_sprintf(char *buf, char const *fmt, ...)
{
    int result;
    va_list va;
    
# 1353 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
   __builtin_va_start(
# 1353 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
   va
# 1353 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
   ,
# 1353 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
   fmt
# 1353 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
   )
# 1353 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                    ;
    result = stbsp_vsprintfcb(0, 0, buf, fmt, va);
    
# 1355 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
   __builtin_va_end(
# 1355 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
   va
# 1355 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
   )
# 1355 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
             ;
    return result;
}

typedef struct stbsp__context {
    char *buf;
    int count;
    int length;
    char tmp[512];
} stbsp__context;

static char *stbsp__clamp_callback(const char *buf, void *user, int len)
{
    stbsp__context *c = (stbsp__context *)user;
    c->length += len;

    if (len > c->count)
        len = c->count;

    if (len) {
        if (buf != c->buf) {
            const char *s, *se;
            char *d;
            d = c->buf;
            s = buf;
            se = buf + len;
            do {
                *d++ = *s++;
            } while (s < se);
        }
        c->buf += len;
        c->count -= len;
    }

    if (c->count <= 0)
        return c->tmp;
    return (c->count >= 512) ? c->buf : c->tmp;
}

static char * stbsp__count_clamp_callback( const char * buf, void * user, int len )
{
    stbsp__context * c = (stbsp__context*)user;
    (void) sizeof(buf);

    c->length += len;
    return c->tmp;
}

extern "C" int stbsp_vsnprintf( char * buf, int count, char const * fmt, va_list va )
{
    stbsp__context c;

    if ( (count == 0) && !buf )
    {
        c.length = 0;

        stbsp_vsprintfcb( stbsp__count_clamp_callback, &c, c.tmp, fmt, va );
    }
    else
    {
        int l;

        c.buf = buf;
        c.count = count;
        c.length = 0;

        stbsp_vsprintfcb( stbsp__clamp_callback, &c, stbsp__clamp_callback(0,&c,0), fmt, va );


        l = (int)( c.buf - buf );
        if ( l >= count )
            l = count - 1;
        buf[l] = 0;
    }

    return c.length;
}

extern "C" int stbsp_snprintf(char *buf, int count, char const *fmt, ...)
{
    int result;
    va_list va;
    
# 1437 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
   __builtin_va_start(
# 1437 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
   va
# 1437 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
   ,
# 1437 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
   fmt
# 1437 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
   )
# 1437 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
                    ;

    result = stbsp_vsnprintf(buf, count, fmt, va);
    
# 1440 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
   __builtin_va_end(
# 1440 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
   va
# 1440 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 3 4
   )
# 1440 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
             ;

    return result;
}

extern "C" int stbsp_vsprintf(char *buf, char const *fmt, va_list va)
{
    return stbsp_vsprintfcb(0, 0, buf, fmt, va);
}
# 1464 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
static signed int stbsp__real_to_parts(signed long long *bits, signed int *expo, double value)
{
    double d;
    signed long long b = 0;


    d = value;

    { int cn; for (cn = 0; cn < 8; cn++) ((char *)&b)[cn] = ((char *)&d)[cn]; };

    *bits = b & ((((unsigned long long)1) << 52) - 1);
    *expo = (signed int)(((b >> 52) & 2047) - 1023);

    return (signed int)((unsigned long long) b >> 63);
}

static double const stbsp__bot[23] = {
    1e+000, 1e+001, 1e+002, 1e+003, 1e+004, 1e+005, 1e+006, 1e+007, 1e+008, 1e+009, 1e+010, 1e+011,
    1e+012, 1e+013, 1e+014, 1e+015, 1e+016, 1e+017, 1e+018, 1e+019, 1e+020, 1e+021, 1e+022
};
static double const stbsp__negbot[22] = {
    1e-001, 1e-002, 1e-003, 1e-004, 1e-005, 1e-006, 1e-007, 1e-008, 1e-009, 1e-010, 1e-011,
    1e-012, 1e-013, 1e-014, 1e-015, 1e-016, 1e-017, 1e-018, 1e-019, 1e-020, 1e-021, 1e-022
};
static double const stbsp__negboterr[22] = {
    -5.551115123125783e-018, -2.0816681711721684e-019, -2.0816681711721686e-020, -4.7921736023859299e-021, -8.1803053914031305e-022, 4.5251888174113741e-023,
    4.5251888174113739e-024, -2.0922560830128471e-025, -6.2281591457779853e-026, -3.6432197315497743e-027, 6.0503030718060191e-028, 2.0113352370744385e-029,
    -3.0373745563400371e-030, 1.1806906454401013e-032, -7.7705399876661076e-032, 2.0902213275965398e-033, -7.1542424054621921e-034, -7.1542424054621926e-035,
    2.4754073164739869e-036, 5.4846728545790429e-037, 9.2462547772103625e-038, -4.8596774326570872e-039
};
static double const stbsp__top[13] = {
    1e+023, 1e+046, 1e+069, 1e+092, 1e+115, 1e+138, 1e+161, 1e+184, 1e+207, 1e+230, 1e+253, 1e+276, 1e+299
};
static double const stbsp__negtop[13] = {
    1e-023, 1e-046, 1e-069, 1e-092, 1e-115, 1e-138, 1e-161, 1e-184, 1e-207, 1e-230, 1e-253, 1e-276, 1e-299
};
static double const stbsp__toperr[13] = {
    8388608,
    6.8601809640529717e+028,
    -7.253143638152921e+052,
    -4.3377296974619174e+075,
    -1.5559416129466825e+098,
    -3.2841562489204913e+121,
    -3.7745893248228135e+144,
    -1.7356668416969134e+167,
    -3.8893577551088374e+190,
    -9.9566444326005119e+213,
    6.3641293062232429e+236,
    -5.2069140800249813e+259,
    -5.2504760255204387e+282
};
static double const stbsp__negtoperr[13] = {
    3.9565301985100693e-040, -2.299904345391321e-063, 3.6506201437945798e-086, 1.1875228833981544e-109,
    -5.0644902316928607e-132, -6.7156837247865426e-155, -2.812077463003139e-178, -5.7778912386589953e-201,
    7.4997100559334532e-224, -4.6439668915134491e-247, -6.3691100762962136e-270, -9.436808465446358e-293,
    8.0970921678014997e-317
};
# 1547 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
static unsigned long long const stbsp__powten[20] = {
    1,
    10,
    100,
    1000,
    10000,
    100000,
    1000000,
    10000000,
    100000000,
    1000000000,
    10000000000ULL,
    100000000000ULL,
    1000000000000ULL,
    10000000000000ULL,
    100000000000000ULL,
    1000000000000000ULL,
    10000000000000000ULL,
    100000000000000000ULL,
    1000000000000000000ULL,
    10000000000000000000ULL
};
# 1611 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h"
static void stbsp__raise_to_power10(double *ohi, double *olo, double d, signed int power)
{
    double ph, pl;
    if ((power >= 0) && (power <= 22)) {
        { double ahi = 0, alo, bhi = 0, blo; signed long long bt; ph = d * stbsp__bot[power]; { int cn; for (cn = 0; cn < 8; cn++) ((char *)&bt)[cn] = ((char *)&d)[cn]; }; bt &= ((~(unsigned long long)0) << 27); { int cn; for (cn = 0; cn < 8; cn++) ((char *)&ahi)[cn] = ((char *)&bt)[cn]; }; alo = d - ahi; { int cn; for (cn = 0; cn < 8; cn++) ((char *)&bt)[cn] = ((char *)&stbsp__bot[power])[cn]; }; bt &= ((~(unsigned long long)0) << 27); { int cn; for (cn = 0; cn < 8; cn++) ((char *)&bhi)[cn] = ((char *)&bt)[cn]; }; blo = stbsp__bot[power] - bhi; pl = ((ahi * bhi - ph) + ahi * blo + alo * bhi) + alo * blo; };
    } else {
        signed int e, et, eb;
        double p2h, p2l;

        e = power;
        if (power < 0)
            e = -e;
        et = (e * 0x2c9) >> 14;
        if (et > 13)
            et = 13;
        eb = e - (et * 23);

        ph = d;
        pl = 0.0;
        if (power < 0) {
            if (eb) {
                --eb;
                { double ahi = 0, alo, bhi = 0, blo; signed long long bt; ph = d * stbsp__negbot[eb]; { int cn; for (cn = 0; cn < 8; cn++) ((char *)&bt)[cn] = ((char *)&d)[cn]; }; bt &= ((~(unsigned long long)0) << 27); { int cn; for (cn = 0; cn < 8; cn++) ((char *)&ahi)[cn] = ((char *)&bt)[cn]; }; alo = d - ahi; { int cn; for (cn = 0; cn < 8; cn++) ((char *)&bt)[cn] = ((char *)&stbsp__negbot[eb])[cn]; }; bt &= ((~(unsigned long long)0) << 27); { int cn; for (cn = 0; cn < 8; cn++) ((char *)&bhi)[cn] = ((char *)&bt)[cn]; }; blo = stbsp__negbot[eb] - bhi; pl = ((ahi * bhi - ph) + ahi * blo + alo * bhi) + alo * blo; };
                pl = pl + (d * stbsp__negboterr[eb]);;
            }
            if (et) {
                { double s; s = ph + pl; pl = pl - (s - ph); ph = s; };
                --et;
                { double ahi = 0, alo, bhi = 0, blo; signed long long bt; p2h = ph * stbsp__negtop[et]; { int cn; for (cn = 0; cn < 8; cn++) ((char *)&bt)[cn] = ((char *)&ph)[cn]; }; bt &= ((~(unsigned long long)0) << 27); { int cn; for (cn = 0; cn < 8; cn++) ((char *)&ahi)[cn] = ((char *)&bt)[cn]; }; alo = ph - ahi; { int cn; for (cn = 0; cn < 8; cn++) ((char *)&bt)[cn] = ((char *)&stbsp__negtop[et])[cn]; }; bt &= ((~(unsigned long long)0) << 27); { int cn; for (cn = 0; cn < 8; cn++) ((char *)&bhi)[cn] = ((char *)&bt)[cn]; }; blo = stbsp__negtop[et] - bhi; p2l = ((ahi * bhi - p2h) + ahi * blo + alo * bhi) + alo * blo; };
                p2l = p2l + (ph * stbsp__negtoperr[et] + pl * stbsp__negtop[et]);;
                ph = p2h;
                pl = p2l;
            }
        } else {
            if (eb) {
                e = eb;
                if (eb > 22)
                    eb = 22;
                e -= eb;
                { double ahi = 0, alo, bhi = 0, blo; signed long long bt; ph = d * stbsp__bot[eb]; { int cn; for (cn = 0; cn < 8; cn++) ((char *)&bt)[cn] = ((char *)&d)[cn]; }; bt &= ((~(unsigned long long)0) << 27); { int cn; for (cn = 0; cn < 8; cn++) ((char *)&ahi)[cn] = ((char *)&bt)[cn]; }; alo = d - ahi; { int cn; for (cn = 0; cn < 8; cn++) ((char *)&bt)[cn] = ((char *)&stbsp__bot[eb])[cn]; }; bt &= ((~(unsigned long long)0) << 27); { int cn; for (cn = 0; cn < 8; cn++) ((char *)&bhi)[cn] = ((char *)&bt)[cn]; }; blo = stbsp__bot[eb] - bhi; pl = ((ahi * bhi - ph) + ahi * blo + alo * bhi) + alo * blo; };
                if (e) {
                    { double s; s = ph + pl; pl = pl - (s - ph); ph = s; };
                    { double ahi = 0, alo, bhi = 0, blo; signed long long bt; p2h = ph * stbsp__bot[e]; { int cn; for (cn = 0; cn < 8; cn++) ((char *)&bt)[cn] = ((char *)&ph)[cn]; }; bt &= ((~(unsigned long long)0) << 27); { int cn; for (cn = 0; cn < 8; cn++) ((char *)&ahi)[cn] = ((char *)&bt)[cn]; }; alo = ph - ahi; { int cn; for (cn = 0; cn < 8; cn++) ((char *)&bt)[cn] = ((char *)&stbsp__bot[e])[cn]; }; bt &= ((~(unsigned long long)0) << 27); { int cn; for (cn = 0; cn < 8; cn++) ((char *)&bhi)[cn] = ((char *)&bt)[cn]; }; blo = stbsp__bot[e] - bhi; p2l = ((ahi * bhi - p2h) + ahi * blo + alo * bhi) + alo * blo; };
                    p2l = p2l + (stbsp__bot[e] * pl);;
                    ph = p2h;
                    pl = p2l;
                }
            }
            if (et) {
                { double s; s = ph + pl; pl = pl - (s - ph); ph = s; };
                --et;
                { double ahi = 0, alo, bhi = 0, blo; signed long long bt; p2h = ph * stbsp__top[et]; { int cn; for (cn = 0; cn < 8; cn++) ((char *)&bt)[cn] = ((char *)&ph)[cn]; }; bt &= ((~(unsigned long long)0) << 27); { int cn; for (cn = 0; cn < 8; cn++) ((char *)&ahi)[cn] = ((char *)&bt)[cn]; }; alo = ph - ahi; { int cn; for (cn = 0; cn < 8; cn++) ((char *)&bt)[cn] = ((char *)&stbsp__top[et])[cn]; }; bt &= ((~(unsigned long long)0) << 27); { int cn; for (cn = 0; cn < 8; cn++) ((char *)&bhi)[cn] = ((char *)&bt)[cn]; }; blo = stbsp__top[et] - bhi; p2l = ((ahi * bhi - p2h) + ahi * blo + alo * bhi) + alo * blo; };
                p2l = p2l + (ph * stbsp__toperr[et] + pl * stbsp__top[et]);;
                ph = p2h;
                pl = p2l;
            }
        }
    }
    { double s; s = ph + pl; pl = pl - (s - ph); ph = s; };
    *ohi = ph;
    *olo = pl;
}





static signed int stbsp__real_to_str(char const **start, unsigned int *len, char *out, signed int *decimal_pos, double value, unsigned int frac_digits)
{
    double d;
    signed long long bits = 0;
    signed int expo, e, ng, tens;

    d = value;
    { int cn; for (cn = 0; cn < 8; cn++) ((char *)&bits)[cn] = ((char *)&d)[cn]; };
    expo = (signed int)((bits >> 52) & 2047);
    ng = (signed int)((unsigned long long) bits >> 63);
    if (ng)
        d = -d;

    if (expo == 2047)
    {
        *start = (bits & ((((unsigned long long)1) << 52) - 1)) ? "NaN" : "Inf";
        *decimal_pos = 0x7000;
        *len = 3;
        return ng;
    }

    if (expo == 0)
    {
        if (((unsigned long long) bits << 1) == 0)
        {
            *decimal_pos = 1;
            *start = out;
            out[0] = '0';
            *len = 1;
            return ng;
        }

        {
            signed long long v = ((unsigned long long)1) << 51;
            while ((bits & v) == 0) {
                --expo;
                v >>= 1;
            }
        }
    }


    {
        double ph, pl;


        tens = expo - 1023;
        tens = (tens < 0) ? ((tens * 617) / 2048) : (((tens * 1233) / 4096) + 1);


        stbsp__raise_to_power10(&ph, &pl, d, 18 - tens);


        { double ahi = 0, alo, vh, t; bits = (signed long long)ph; vh = (double)bits; ahi = (ph - vh); t = (ahi - ph); alo = (ph - (ahi - t)) - (vh + t); bits += (signed long long)(ahi + alo + pl); };


        if (((unsigned long long)bits) >= (1000000000000000000ULL))
            ++tens;
    }


    frac_digits = (frac_digits & 0x80000000) ? ((frac_digits & 0x7ffffff) + 1) : (tens + frac_digits);
    if ((frac_digits < 24)) {
        unsigned int dg = 1;
        if ((unsigned long long)bits >= stbsp__powten[9])
            dg = 10;
        while ((unsigned long long)bits >= stbsp__powten[dg]) {
            ++dg;
            if (dg == 20)
                goto noround;
        }
        if (frac_digits < dg) {
            unsigned long long r;

            e = dg - frac_digits;
            if ((unsigned int)e >= 24)
                goto noround;
            r = stbsp__powten[e];
            bits = bits + (r / 2);
            if ((unsigned long long)bits >= stbsp__powten[dg])
                ++tens;
            bits /= r;
        }
        noround:;
    }


    if (bits) {
        unsigned int n;
        for (;;) {
            if (bits <= 0xffffffff)
                break;
            if (bits % 1000)
                goto donez;
            bits /= 1000;
        }
        n = (unsigned int)bits;
        while ((n % 1000) == 0)
            n /= 1000;
        bits = n;
        donez:;
    }


    out += 64;
    e = 0;
    for (;;) {
        unsigned int n;
        char *o = out - 8;

        if (bits >= 100000000) {
            n = (unsigned int)(bits % 100000000);
            bits /= 100000000;
        } else {
            n = (unsigned int)bits;
            bits = 0;
        }
        while (n) {
            out -= 2;
            *(unsigned short *)out = *(unsigned short *)&stbsp__digitpair.pair[(n % 100) * 2];
            n /= 100;
            e += 2;
        }
        if (bits == 0) {
            if ((e) && (out[0] == '0')) {
                ++out;
                --e;
            }
            break;
        }
        while (out != o) {
            *--out = '0';
            ++e;
        }
    }

    *decimal_pos = tens;
    *start = out;
    *len = e;
    return ng;
}
# 22 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp" 2


char const *GeneratedTag = "/**   GENERATED    **/";

inline void
WriteToOutput(output_data *Output, memory_arena *Memory, char const *String, ...)
{
    va_list Args;
    
# 30 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp" 3 4
   __builtin_va_start(
# 30 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp"
   Args
# 30 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp" 3 4
   ,
# 30 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp"
   String
# 30 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp" 3 4
   )
# 30 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp"
                          ;

    output_data *OutputPtr = Output;
    while(OutputPtr->Next)
    {
        OutputPtr = OutputPtr->Next;
    }

    const size_t OutputTotalSize = (sizeof(Output->OutputString)) / (sizeof(Output->OutputString[1]));
    size_t Index = OutputPtr->Used;
    size_t OutputEmptySize = OutputTotalSize - OutputPtr->Used;

    size_t NumChars = stbsp_vsnprintf(&OutputPtr->OutputString[Index], OutputEmptySize, String, Args);

    if(NumChars < OutputEmptySize)
    {
        OutputPtr->Used += NumChars;
    }
    else
    {



        OutputPtr->OutputString[Index] = 0;
        OutputPtr->Next = (output_data*)abm_PushSize_(Memory, sizeof(output_data));
        OutputPtr = OutputPtr->Next;
        s32 NumChars = stbsp_vsnprintf(&OutputPtr->OutputString[Index], OutputEmptySize, String, Args);
        OutputPtr->Used += NumChars;
    }

    
# 60 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp" 3 4
   __builtin_va_end(
# 60 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp"
   Args
# 60 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp" 3 4
   )
# 60 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp"
               ;
}

inline void
CopyToOutput(output_data *Output, memory_arena *Memory, char const* String)
{
    output_data *OutputPtr = Output;
    const size_t OutputTotalSize = (sizeof(Output->OutputString)) / (sizeof(Output->OutputString[1]));
    s32 StringLen = strlen(String);
    s32 StringIndex = 0;
    while(StringIndex < StringLen)
    {
        size_t Index = OutputPtr->Used;
        size_t OutputEmptySize = OutputTotalSize - OutputPtr->Used;
        if(OutputEmptySize > 1)
        {
            u32 MaxLen = ((((s32)OutputEmptySize) < (StringLen)) ? ((s32)OutputEmptySize) : (StringLen));
            abs_StringCopy(&OutputPtr->OutputString[Index], String, MaxLen);
            OutputPtr->Used += MaxLen;
            StringIndex += MaxLen;
        }
        else
        {
            if(OutputPtr->Next == 0)
            {
                OutputPtr->Next = (output_data*)abm_PushSize_(Memory, sizeof(output_data));
            }
            OutputPtr = OutputPtr->Next;
        }

    }

}

inline void
CopyToOutput(output_data *ToOutput, memory_arena *Memory, output_data *FromOutput)
{
    output_data *OutputPtr = ToOutput;
    while(OutputPtr)
    {
        CopyToOutput(OutputPtr, Memory, FromOutput->OutputString);
        OutputPtr = OutputPtr->Next;
    }
}


# 1 "/home/amos/prog/c/amos_libraries/preprocessor/abp_queue.h" 1





# 1 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_string.h" 1
# 7 "/home/amos/prog/c/amos_libraries/preprocessor/abp_queue.h" 2
# 1 "/home/amos/prog/c/amos_libraries/preprocessor/ab_parser.h" 1
# 8 "/home/amos/prog/c/amos_libraries/preprocessor/abp_queue.h" 2

void
WriteQueueFunctions(abs_stringptr QueueItemName, u32 QueueSize,
                    memory_arena *Memory, output_data *Headers, output_data *Definitions);





void
WriteQueueFunctions(abs_stringptr QueueItemName, u32 QueueSize,
                    memory_arena *Memory, output_data *Headers, output_data *Definitions)
{
    WriteToOutput(Headers, Memory,
                  "/***** Queue: %.*s ****/\n"
                  "// Creating a circular queue of %u elements.\n",
                  QueueItemName.Length, QueueItemName.String, QueueSize);

    WriteToOutput(Headers, Memory,
                  "struct %.*s_queue\n"
                  "{\n"
                  "    %.*s Items[%u];\n"
                  "    s32 Front;\n"
                  "    s32 Rear;\n"
                  "};\n"
                  "\n",
                  QueueItemName.Length, QueueItemName.String,
                  QueueItemName.Length, QueueItemName.String,
                  QueueSize
                  );

    WriteToOutput(Headers, Memory,
                  "inline void InitializeQueue(%.*s_queue *Queue);\n"
                  "inline b8 "
                  "isQueueEmpty(%.*s_queue *Queue);\n"
                  "inline b8 "
                  "isQueueFull(%.*s_queue *Queue);\n"
                  "b8 "
                  "EnqueueCommand(%.*s_queue *Queue, %.*s Cmd);\n"
                  "%.*s "
                  "DequeueCommand(%.*s_queue *Queue);\n",
                  QueueItemName.Length, QueueItemName.String,
                  QueueItemName.Length, QueueItemName.String,
                  QueueItemName.Length, QueueItemName.String,
                  QueueItemName.Length, QueueItemName.String,
                  QueueItemName.Length, QueueItemName.String,
                  QueueItemName.Length, QueueItemName.String,
                  QueueItemName.Length, QueueItemName.String);

    WriteToOutput(Headers, Memory,
                  "/***********/\n\n");

    WriteToOutput(Definitions, Memory, "/****** Queue: %.*s ****/\n",
                  QueueItemName.Length, QueueItemName.String);

    WriteToOutput(Definitions, Memory,
                  "inline void\n"
                  "InitializeQueue(%.*s_queue *Queue)\n"
                  "{\n"
                  "  Queue->Front = Queue->Rear = -1;\n"
                  "}\n\n",
                  QueueItemName.Length, QueueItemName.String);

    WriteToOutput(Definitions, Memory,
                  "inline b8\n"
                  "isQueueEmpty(%.*s_queue *Queue)\n"
                  "{\n"
                  "  b8 Result = (Queue->Front == -1);\n"
                  "  return Result;\n"
                  "}\n"
                  "\n",
                  QueueItemName.Length, QueueItemName.String);

    WriteToOutput(Definitions, Memory,
                  "inline b8 \n"
                  "isQueueFull(%.*s_queue *Queue)\n"
                  "{\n"
                  "  b8 Result = (Queue->Front == Queue->Rear + 1) ||\n"
                  "  (Queue->Front == 0 && Queue->Rear == (%u-1));\n"
                  "\n"
                  "  return Result;\n"
                  "}\n"
                  "\n",
                  QueueItemName.Length, QueueItemName.String,
                  QueueSize);

    WriteToOutput(Definitions, Memory,
                  "b8\n"
                  "Enqueue(%.*s_queue *Queue, %.*s Cmd)\n"
                  "{\n"
                  "  b8 Result = false;\n"
                  "  if(!isQueueFull(Queue))\n"
                  "  {\n"
                  "    if(Queue->Front == -1)\n"
                  "    {\n"
                  "      Queue->Front = 0;\n"
                  "    }\n"
                  "    Queue->Rear = (Queue->Rear + 1) %% %u;\n"
                  "    Queue->Items[Queue->Rear] = Cmd;\n"
                  "\n"
                  "    Result = true;\n"
                  "  }\n"
                  "  return Result;    \n"
                  "}\n"
                  "\n",
                  QueueItemName.Length, QueueItemName.String,
                  QueueItemName.Length, QueueItemName.String,
                  QueueSize);

    WriteToOutput(Definitions, Memory,
                  "%.*s\n"
                  "Dequeue(%.*s_queue *Queue)\n"
                  "{\n"
                  "%.*s Result = (%.*s)0;\n"
                  "if(!isQueueEmpty(Queue))\n"
                  "{\n"
                  "Result = Queue->Items[Queue->Front];\n"
                  "if(Queue->Front == Queue->Rear)\n"
                  "{\n"
                  "Queue->Front = Queue->Rear = -1;\n"
                  "}\n"
                  "else \n"
                  "{\n"
                  "Queue->Front = (Queue->Front + 1) %% %u;\n"
                  "}\n"
                  "}\n"
                  "\n"
                  "return Result;\n"
                  "}\n"
                  "\n",
                  QueueItemName.Length, QueueItemName.String,
                  QueueItemName.Length, QueueItemName.String,
                  QueueItemName.Length, QueueItemName.String,
                  QueueItemName.Length, QueueItemName.String,
                  QueueSize);

    WriteToOutput(Definitions, Memory,
                  "/***********/\n\n");

}
# 107 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp" 2

# 1 "/home/amos/prog/c/amos_libraries/preprocessor/abp_enums.cpp" 1
# 1 "/home/amos/prog/c/amos_libraries/preprocessor/ab_parser.h" 1
# 2 "/home/amos/prog/c/amos_libraries/preprocessor/abp_enums.cpp" 2
# 1 "/home/amos/prog/c/amos_libraries/preprocessor/ab_lexer.h" 1
# 3 "/home/amos/prog/c/amos_libraries/preprocessor/abp_enums.cpp" 2

void
CreateEnumJson(term_enum *Enum, tag *Tag,
               memory_arena *Memory, output_data *DefinitionsOut, output_data *FunctionsOut)
{
    temporary_memory TempMem = abm_BeginTemporaryMemory(Memory);
    const u32 MaxSectionSize = (1024ULL * (5));
    char *HeaderScratch = (char*)abm_PushSize_(Memory, MaxSectionSize);
    char *FunctionScratch = (char*)abm_PushSize_(Memory, MaxSectionSize);
    HeaderScratch[0] = 0;
    FunctionScratch[0] = 0;
    u32 HeaderCount = 0;
    u32 FunctionCount = 0;


    if(Enum->ItemCount > 0)
    {

        HeaderCount += stbsp_snprintf(&HeaderScratch[HeaderCount], (MaxSectionSize - HeaderCount),
                                      "jsmntok_t *JsonToObject(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, jsmntok_t *TokenArray, %.*s *ObjectOut, u32 Unused);\n",
                                      Enum->Name.Length, Enum->Name.String);
        HeaderCount += stbsp_snprintf(&HeaderScratch[HeaderCount], (MaxSectionSize - HeaderCount),
                                      "u32\n"
                                      "PushJson(char *Json, u32 MaxLength, char const *Tag, %.*s Type, u32 JsonFlags);\n",
                                      Enum->Name.Length, Enum->Name.String);

        FunctionCount += stbsp_snprintf(&FunctionScratch[FunctionCount], (MaxSectionSize - FunctionCount),
                                        "u32\n"
                                        "PushJson(char *Json, u32 MaxLength, char const *Tag, %.*s Type, u32 JsonFlags = 0)\n"
                                        "{\n"
                                        "    u32 Length = 0;\n"
                                        "    b8 isLast = (JsonFlags & JSON_IsLastInList);\n"
                                        "    Length += stbsp_snprintf(Json, MaxLength, \"\\\"%%s\\\":\\\"%%s\\\"\", Tag, EnumToCString(Type));\n"

                                        "    if(!isLast) { Json[Length++] = ','; }\n"
                                        "    return Length;\n}\n\n",
                                        Enum->Name.Length, Enum->Name.String
                                        );


        FunctionCount += stbsp_snprintf(&FunctionScratch[FunctionCount], (MaxSectionSize - FunctionCount),
                                        "jsmntok_t *JsonToObject(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, jsmntok_t *TokenArray, %.*s *ObjectOut, u32 Unused)\n",
                                        Enum->Name.Length, Enum->Name.String);



        FunctionCount += stbsp_snprintf(&FunctionScratch[FunctionCount], (MaxSectionSize - FunctionCount),
                                        "{\n"
                                        "    %.*s Result = static_cast<%.*s>(0);\n"
                                        "    s32 NumTokensUsed = 0;\n"
                                        "    \n"
                                        "    s32 TotalTokens = ParseJson(VolatileMemory, Json, JsonLength, &TokenArray);\n"
                                        "    if(TokenArray)\n"
                                        "    {\n"
                                        "        s32 Index = 0;\n"
                                        "        if((TokenArray[Index].type == JSMN_OBJECT) &&\n"
                                        "           (TotalTokens > 1))\n"
                                        "        {\n"
                                        "            ++Index;\n"
                                        "        }\n"
                                        "        if(TokenArray[Index].type == JSMN_STRING)\n"
                                        "        {\n"
                                        "            s32 TokenLength = (TokenArray[Index].end - TokenArray[Index].start);\n"
                                        "            abs_stringptr EnumString = {&Json[TokenArray[Index].start], TokenLength};\n"
                                        "            Result = StringToEnum<%.*s>(EnumString);\n"
                                        "            NumTokensUsed = Index;\n"
                                        "        }\n"
                                        "        else \n"
                                        "        {\n"
                                        "            NumTokensUsed = Index;\n"
                                        "        }\n"
                                        "    }\n"
                                        "    *ObjectOut = Result;\n"
                                        "    return TokenArray + NumTokensUsed;\n"
                                        "}\n\n",
                                        Enum->Name.Length, Enum->Name.String,
                                        Enum->Name.Length, Enum->Name.String,
                                        Enum->Name.Length, Enum->Name.String
                                        );

        ;
        FunctionScratch[FunctionCount] = 0;

        CopyToOutput(DefinitionsOut, Memory, HeaderScratch);
        CopyToOutput(FunctionsOut, Memory, FunctionScratch);
        abm_EndTemporaryMemory(TempMem);
    }
}

void
CreateEnumLabels(term_enum *Enum, tag *LabelTag, memory_arena *Memory, output_data *DefinitionsOut, output_data *FunctionsOut)
{
    temporary_memory TempMem = abm_BeginTemporaryMemory(Memory);
    const u32 MaxSectionSize = (1024ULL * (10));
    char *HeaderScratch = (char*)abm_PushSize_(Memory, MaxSectionSize);
    char *FunctionScratch = (char*)abm_PushSize_(Memory, MaxSectionSize);
    HeaderScratch[0] = 0;
    FunctionScratch[0] = 0;
    u32 HeaderCount = 0;
    u32 FunctionCount = 0;


    if(Enum->ItemCount > 0)
    {




        HeaderCount += stbsp_snprintf(&HeaderScratch[HeaderCount], (MaxSectionSize - HeaderCount),
                                      "const char *EnumToLabel_%.*s(%.*s EnumToken);\n"
                                      "//const char * %.*s_Label%.*s[%.*s_Count];\n",
                                      LabelTag->Option.Length, LabelTag->Option.String,
                                      Enum->Name.Length, Enum->Name.String,
                                      Enum->Name.Length, Enum->Name.String,
                                      LabelTag->Option.Length, LabelTag->Option.String,
                                      Enum->Name.Length, Enum->Name.String);

        HeaderCount += stbsp_snprintf(&HeaderScratch[HeaderCount], (MaxSectionSize - HeaderCount),
                                      "const char * %.*s_Label%.*s[%.*s_Count] = \n"
                                      "{\n",
                                      Enum->Name.Length, Enum->Name.String,
                                      LabelTag->Option.Length, LabelTag->Option.String,
                                      Enum->Name.Length, Enum->Name.String);


        term_enumitem *CurrentItem = Enum->ItemListSentinal.Next;
        while(CurrentItem != &Enum->ItemListSentinal)
        {
            abs_stringptr Label = {};
            tag *CurrentTag = CurrentItem->TagListSentinal.Next;
            while(CurrentTag != &CurrentItem->TagListSentinal)
            {
                if(abs_AreStringsEqual(CurrentTag->Name, LabelTag->Option))
                {
                    Label = CurrentTag->Option;
                    break;
                }
                CurrentTag = CurrentTag->Next;
            }

            if(Label.Length == 0)
            {
                Label = CurrentItem->Name;
            }

            HeaderCount += stbsp_snprintf(&HeaderScratch[HeaderCount], (MaxSectionSize - HeaderCount),
                                          "    \"%.*s\",\n",
                                          Label.Length, Label.String);

            CurrentItem = CurrentItem->Next;
        }

        HeaderCount += stbsp_snprintf(&HeaderScratch[HeaderCount], (MaxSectionSize - HeaderCount), "};\n\n");

        FunctionCount += stbsp_snprintf(&FunctionScratch[FunctionCount], (MaxSectionSize - FunctionCount),
                                        "const char *\n"
                                        "EnumToLabel_%.*s(%.*s EnumToken)\n"
                                        "{\n"
                                        "    return %.*s_Label%.*s[int(EnumToken)];\n"
                                        "}\n\n",
                                        LabelTag->Option.Length, LabelTag->Option.String,
                                        Enum->Name.Length, Enum->Name.String,
                                        Enum->Name.Length, Enum->Name.String,
                                        LabelTag->Option.Length, LabelTag->Option.String);

        ;
        FunctionScratch[FunctionCount] = 0;


        CopyToOutput(DefinitionsOut, Memory, HeaderScratch);
        CopyToOutput(FunctionsOut, Memory, FunctionScratch);

    }
    abm_EndTemporaryMemory(TempMem);
}

void
CreateEnumStrings(term_enum *Enum, tag *Tag,
                  memory_arena *Memory, output_data *DefinitionsOut, output_data *FunctionsOut)
{
    temporary_memory TempMem = abm_BeginTemporaryMemory(Memory);
    const u32 MaxSectionSize = (1024ULL * (10));
    char *HeaderScratch = (char*)abm_PushSize_(Memory, MaxSectionSize);
    char *FunctionScratch = (char*)abm_PushSize_(Memory, MaxSectionSize);
    HeaderScratch[0] = 0;
    FunctionScratch[0] = 0;
    u32 HeaderCount = 0;
    u32 FunctionCount = 0;


    if(Enum->ItemCount > 0)
    {
        HeaderCount += stbsp_snprintf(&HeaderScratch[HeaderCount], (MaxSectionSize - HeaderCount),
                                      "template<>\n"
                                      "auto StringToEnum<%.*s>(const char *String) -> %.*s;\n"
                                      "template<>\n"
                                      "auto StringToEnum<%.*s>(abs_stringptr String) -> %.*s;\n"
                                      "constexpr abs_stringptr EnumToString(%.*s EnumToken);\n"
                                      "constexpr char const* EnumToCString(%.*s EnumToken);\n"
                                      "constexpr abs_stringptr %.*s_Strings[%.*s_Count] = \n{\n",
                                      Enum->Name.Length, Enum->Name.String,
                                      Enum->Name.Length, Enum->Name.String,
                                      Enum->Name.Length, Enum->Name.String,
                                      Enum->Name.Length, Enum->Name.String,
                                      Enum->Name.Length, Enum->Name.String,
                                      Enum->Name.Length, Enum->Name.String,
                                      Enum->Name.Length, Enum->Name.String,
                                      Enum->Name.Length, Enum->Name.String);
# 219 "/home/amos/prog/c/amos_libraries/preprocessor/abp_enums.cpp"
        term_enumitem *CurrentItem = Enum->ItemListSentinal.Next;
        while(CurrentItem != &Enum->ItemListSentinal)
        {
            HeaderCount += stbsp_snprintf(&HeaderScratch[HeaderCount], (MaxSectionSize - HeaderCount),
                                          "   {\"%.*s\", %u},\n",
                                          CurrentItem->Name.Length, CurrentItem->Name.String,
                                          CurrentItem->Name.Length);

            CurrentItem = CurrentItem->Next;
        }

        HeaderCount += stbsp_snprintf(&HeaderScratch[HeaderCount], (MaxSectionSize - HeaderCount), "};\n\n");


        FunctionCount += stbsp_snprintf(&FunctionScratch[FunctionCount], (MaxSectionSize - FunctionCount),
                                        "template<>\n"
                                        "auto StringToEnum<%.*s>(const char *String) -> %.*s\n",
                                        Enum->Name.Length, Enum->Name.String,
                                        Enum->Name.Length, Enum->Name.String);


        FunctionCount += stbsp_snprintf(&FunctionScratch[FunctionCount], (MaxSectionSize - FunctionCount),
                                        "{\n"
                                        "    u32 StringIndex = abs_FindInList(String, %.*s_Count, %.*s_Strings, true);\n",
                                        Enum->Name.Length, Enum->Name.String,
                                        Enum->Name.Length, Enum->Name.String);

        FunctionCount += stbsp_snprintf(&FunctionScratch[FunctionCount], (MaxSectionSize - FunctionCount),
                                        "    %.*s Result = %.*s::%.*s;\n",
                                        Enum->Name.Length, Enum->Name.String,
                                        Enum->Name.Length, Enum->Name.String,
                                        Enum->ItemListSentinal.Next->Name.Length, Enum->ItemListSentinal.Next->Name.String);

        FunctionCount += stbsp_snprintf(&FunctionScratch[FunctionCount], (MaxSectionSize - FunctionCount),
                                        "    if(StringIndex < %.*s_Count)\n"
                                        "    {\n"
                                        "        Result = static_cast<%.*s>(StringIndex);\n"
                                        "    }\n"
                                        "    return Result;\n"
                                        "}\n",
                                        Enum->Name.Length, Enum->Name.String,
                                        Enum->Name.Length, Enum->Name.String);

        FunctionCount += stbsp_snprintf(&FunctionScratch[FunctionCount], (MaxSectionSize - FunctionCount),
                                        "template<>\n"
                                        "auto StringToEnum<%.*s>(abs_stringptr String) -> %.*s\n",
                                        Enum->Name.Length, Enum->Name.String,
                                        Enum->Name.Length, Enum->Name.String);


        FunctionCount += stbsp_snprintf(&FunctionScratch[FunctionCount], (MaxSectionSize - FunctionCount),
                                        "{\n"
                                        "    u32 StringIndex = abs_FindInList(String, %.*s_Count, %.*s_Strings, true);\n",
                                        Enum->Name.Length, Enum->Name.String,
                                        Enum->Name.Length, Enum->Name.String);

        FunctionCount += stbsp_snprintf(&FunctionScratch[FunctionCount], (MaxSectionSize - FunctionCount),
                                        "    %.*s Result = %.*s::%.*s;\n",
                                        Enum->Name.Length, Enum->Name.String,
                                        Enum->Name.Length, Enum->Name.String,
                                        Enum->ItemListSentinal.Next->Name.Length, Enum->ItemListSentinal.Next->Name.String);

        FunctionCount += stbsp_snprintf(&FunctionScratch[FunctionCount], (MaxSectionSize - FunctionCount),
                                        "    if(StringIndex < %.*s_Count)\n"
                                        "    {\n"
                                        "        Result = static_cast<%.*s>(StringIndex);\n"
                                        "    }\n"
                                        "    return Result;\n"
                                        "}\n",
                                        Enum->Name.Length, Enum->Name.String,
                                        Enum->Name.Length, Enum->Name.String);

        FunctionCount += stbsp_snprintf(&FunctionScratch[FunctionCount], (MaxSectionSize - FunctionCount),
                                        "constexpr const char *\n"
                                        "EnumToCString(%.*s EnumToken)\n"
                                        "{\n"
                                        "    return %.*s_Strings[int(EnumToken)].String;\n"
                                        "}\n\n",
                                        Enum->Name.Length, Enum->Name.String,
                                        Enum->Name.Length, Enum->Name.String);

        FunctionCount += stbsp_snprintf(&FunctionScratch[FunctionCount], (MaxSectionSize - FunctionCount),
                                        "constexpr abs_stringptr\n"
                                        "EnumToString(%.*s EnumToken)\n"
                                        "{\n"
                                        "    return %.*s_Strings[int(EnumToken)];\n"
                                        "}\n\n",
                                        Enum->Name.Length, Enum->Name.String,
                                        Enum->Name.Length, Enum->Name.String);

        ;
        FunctionScratch[FunctionCount] = 0;


        CopyToOutput(DefinitionsOut, Memory, HeaderScratch);
        CopyToOutput(FunctionsOut, Memory, FunctionScratch);

    }
    abm_EndTemporaryMemory(TempMem);
}

void
ProcessEnums(term_enum *EnumListSentinal, memory_arena *Memory, output_data *Headers, output_data *Definitions)
{
    term_enum *Enum = EnumListSentinal->Next;
    while(Enum != EnumListSentinal)
    {
        WriteToOutput(Headers, Memory,
                      "/****** Enum %.*s Header *****/\n",
                      Enum->Name.Length, Enum->Name.String);

        WriteToOutput(Headers, Memory,
                      "enum class %.*s;\n",
                      Enum->Name.Length, Enum->Name.String);
        WriteToOutput(Headers, Memory, "const u32 %.*s_Count = %u;\n",
                      Enum->Name.Length, Enum->Name.String,
                      Enum->ItemCount);

        WriteToOutput(Definitions, Memory,
                      "/****** Enum %.*s Functions *****/\n", Enum->Name.Length, Enum->Name.String);

        tag *Tag = Enum->TagListSentinal.Next;
        while(Tag != &Enum->TagListSentinal)
        {
            if(abs_AreStringsEqual(Tag->Name, "Strings"))
            {
                CreateEnumStrings(Enum, Tag, Memory, Headers, Definitions);
            }

            else if(abs_AreStringsEqual(Tag->Name, "JSON"))
            {
                CreateEnumJson(Enum, Tag, Memory, Headers, Definitions);
            }

            else if(abs_AreStringsEqual(Tag->Name, "Label"))
            {
                CreateEnumLabels(Enum, Tag, Memory, Headers, Definitions);
            }

            Tag = Tag->Next;
        }

        WriteToOutput(Headers, Memory, "\n");
        WriteToOutput(Definitions, Memory, "\n");

        Enum = Enum->Next;
    }
}
# 109 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp" 2
# 1 "/home/amos/prog/c/amos_libraries/preprocessor/abp_statefunctions.cpp" 1
# 1 "/home/amos/prog/c/amos_libraries/preprocessor/abp_queue.h" 1
# 2 "/home/amos/prog/c/amos_libraries/preprocessor/abp_statefunctions.cpp" 2

void
ProcessStateFunctions(term_statemachine *MachineListSentinal, term_definedfunction *DefinedFunctionListSentinal,
                      memory_arena *Memory, output_data *Headers, output_data *Definitions)
{

    term_statemachine *CurrentMachine = MachineListSentinal->Next;
    while(CurrentMachine != MachineListSentinal)
    {
        abs_stringptr Capitalize = abs_Capitalize(CurrentMachine->Function, Memory);
        abs_stringptr Lowercase = abs_Lowercase(CurrentMachine->Function, Memory);
        const u32 BufferSize = 300;
        char Buffer[BufferSize] = {};
        int Index = 0;

        WriteToOutput(Headers, Memory,
                      "/****  StateMachine: %.*s ****/\n",
                      Capitalize.Length, Capitalize.String);

        WriteToOutput(Headers, Memory,
                      "struct %.*s;\n"
                      "enum class %.*s;\n",
                      CurrentMachine->Type.Length, CurrentMachine->Type.String,
                      CurrentMachine->Cmd.Length, CurrentMachine->Cmd.String);

        WriteQueueFunctions(CurrentMachine->Cmd, 10, Memory, Headers, Definitions);

        Index += stbsp_snprintf(&Buffer[Index], (BufferSize - Index),
                                "#define %.*s(name) void name(%.*s *State, %.*s Cmd",
                                Capitalize.Length, Capitalize.String,
                                CurrentMachine->Type.Length, CurrentMachine->Type.String,
                                CurrentMachine->Cmd.Length, CurrentMachine->Cmd.String);

        term_typeexpr *CurrentType = CurrentMachine->TypeListSentinal.Next;
        while(CurrentType != &CurrentMachine->TypeListSentinal)
        {
            Index += stbsp_snprintf(&Buffer[Index], (BufferSize - Index),
                                    ", %.*s ",
                                    CurrentType->Type.Length, CurrentType->Type.String);
            if(CurrentType->isConst)
            {
                Index += stbsp_snprintf(&Buffer[Index], (BufferSize - Index), "const ");
            }
            if(CurrentType->isPtr)
            {
                Index += stbsp_snprintf(&Buffer[Index], (BufferSize - Index), "*");
            }
            else if(CurrentType->isReference)
            {
                Index += stbsp_snprintf(&Buffer[Index], (BufferSize - Index), "&");
            }
            Index += stbsp_snprintf(&Buffer[Index], (BufferSize - Index),
                                    "%.*s",
                                    CurrentType->Name.Length, CurrentType->Name.String);
            if(CurrentType->isArray)
            {
                Index += stbsp_snprintf(&Buffer[Index], (BufferSize - Index),
                                        "[%d]",
                                        CurrentType->ArrayLength);
            }

            switch(CurrentType->CustomType)
            {
                case CT_Struct:
                {
                    WriteToOutput(Headers, Memory, "struct %.*s;\n",
                                  CurrentType->Type.Length, CurrentType->Type.String);
                }break;
                case CT_Enum:
                {
                    WriteToOutput(Headers, Memory, "enum class %.*s;\n",
                                  CurrentType->Type.Length, CurrentType->Type.String);
                }break;
                case CT_Union:
                {
                    WriteToOutput(Headers, Memory, "union %.*s;\n",
                                  CurrentType->Type.Length, CurrentType->Type.String);
                }break;
                case CT_Class:
                {
                    WriteToOutput(Headers, Memory, "class %.*s;\n",
                                  CurrentType->Type.Length, CurrentType->Type.String);
                }break;
                default:{}break;
            }

            CurrentType = CurrentType->Next;
        }

        Index += stbsp_snprintf(&Buffer[Index], (BufferSize - Index), ")\n");
        CopyToOutput(Headers, Memory, Buffer);
        WriteToOutput(Headers, Memory, "typedef %.*s(%.*s);\n\n",
                      Capitalize.Length, Capitalize.String,
                      Lowercase.Length, Lowercase.String);
        WriteToOutput(Headers, Memory,
                      "inline b8 GoToState(%.*s *State, %.*s *NewState);\n"
                      "char const *GetStateName(%.*s *StateName);\n"
                      "b8 EnqueueCommand(%.*s *State, %.*s Cmd);\n"
                      "%.*s DequeueCommand(%.*s *State);\n",
                      CurrentMachine->Type.Length, CurrentMachine->Type.String,
                      Lowercase.Length, Lowercase.String,
                      Lowercase.Length, Lowercase.String,
                      CurrentMachine->Type.Length, CurrentMachine->Type.String,
                      CurrentMachine->Cmd.Length, CurrentMachine->Cmd.String,
                      CurrentMachine->Cmd.Length, CurrentMachine->Cmd.String,
                      CurrentMachine->Type.Length, CurrentMachine->Type.String);

        WriteToOutput(Headers, Memory, "\n");

        WriteToOutput(Definitions, Memory,
                      "/**** StateMachine: %.*s **/\n"
                      "// Function Definitions\n",
                      Capitalize.Length, Capitalize.String);
        WriteToOutput(Definitions, Memory,
                      "inline b8\n"
                      "GoToState(%.*s *State, %.*s *NewState)\n",
                      CurrentMachine->Type.Length, CurrentMachine->Type.String,
                      Lowercase.Length, Lowercase.String);
        WriteToOutput(Definitions, Memory,
                      "{\n"
                      "    b8 isChanged = false;\n"
                      "    if(NewState && State)\n"
                      "    {\n"
                      "        State->CurrentState = NewState;\n"
                      "        State->isNewState = true;\n"
                      "    }\n"
                      "\n"
                      "    return isChanged;\n"
                      "}\n"
                      "\n");
        WriteToOutput(Definitions, Memory,
                      "char const*\n"
                      "GetStateName(%.*s *StateName)\n"
                      "{\n",
                      Lowercase.Length, Lowercase.String);


        term_definedfunction *CurrentFunction = DefinedFunctionListSentinal->Next;
        while(CurrentFunction != DefinedFunctionListSentinal)
        {
            if(abs_AreStringsEqual(CurrentMachine->Function, CurrentFunction->Define, true))
            {
                WriteToOutput(Headers, Memory,
                              "%.*s(%.*s);\n",
                              Capitalize.Length, Capitalize.String,
                              CurrentFunction->Name.Length, CurrentFunction->Name.String);

                WriteToOutput(Definitions, Memory,
                              "if(StateName == %.*s) {return \"%.*s\";}\n",
                              CurrentFunction->Name.Length, CurrentFunction->Name.String,
                              CurrentFunction->Name.Length, CurrentFunction->Name.String);
            }
            CurrentFunction = CurrentFunction->Next;
        }

        WriteToOutput(Definitions, Memory,
                      "return \"Unknown\";\n"
                      "}\n\n");

        WriteToOutput(Definitions, Memory,
                      "b8\n"
                      "EnqueueCommand(%.*s *State, %.*s Cmd)\n"
                      "{\n"
                      "return Enqueue(&State->CommandQueue, Cmd);\n"
                      "}\n"
                      "\n"
                      "%.*s\n"
                      "DequeueCommand(%.*s *State)\n"
                      "{\n"
                      "return Dequeue(&State->CommandQueue);\n"
                      "}\n\n",
                      CurrentMachine->Type.Length, CurrentMachine->Type.String,
                      CurrentMachine->Cmd.Length, CurrentMachine->Cmd.String,
                      CurrentMachine->Cmd.Length, CurrentMachine->Cmd.String,
                      CurrentMachine->Type.Length, CurrentMachine->Type.String);

        WriteToOutput(Headers, Memory, "\n/*********/\n\n");
        WriteToOutput(Definitions, Memory, "\n/*********/\n\n");

        CurrentMachine = CurrentMachine->Next;
    }


}
# 110 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp" 2
# 1 "/home/amos/prog/c/amos_libraries/preprocessor/abp_structs.cpp" 1
# 1 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_string.h" 1
# 2 "/home/amos/prog/c/amos_libraries/preprocessor/abp_structs.cpp" 2
# 1 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory.h" 1
# 47 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory.h"
# 1 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory_linux.h" 1
# 48 "/home/amos/prog/c/amos_libraries/preprocessor/../include/ab_memory.h" 2
# 3 "/home/amos/prog/c/amos_libraries/preprocessor/abp_structs.cpp" 2
# 1 "/home/amos/prog/c/amos_libraries/preprocessor/../include/stb_sprintf.h" 1
# 4 "/home/amos/prog/c/amos_libraries/preprocessor/abp_structs.cpp" 2

void
CreateStructJson(term_struct *Struct, tag *Tag, memory_arena *Memory, output_data *Headers, output_data *Definitions)
{
    WriteToOutput(Headers, Memory,
                  "u32 PushJson(char *Json, u32 MaxLength, char const *Tag, const %.*s &Value, u32 JsonFlags);\n",
                  Struct->Name.Length, Struct->Name.String);
    WriteToOutput(Headers, Memory, "struct %.*s_existlist;\n", Struct->Name.Length, Struct->Name.String);
    WriteToOutput(Headers, Memory,
                  "jsmntok_t *JsonToObject(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, jsmntok_t *TokenArray, %.*s *ObjectOut, %.*s_existlist *ItemsExistOut);\n",
                  Struct->Name.Length, Struct->Name.String,
                  Struct->Name.Length, Struct->Name.String);
    WriteToOutput(Headers,Memory,
                  "u32\n"
                  "JsonArrayToObjectArray(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, %.*s **ObjectArray, %.*s_existlist **ObjectArrayExist);\n",
                  Struct->Name.Length, Struct->Name.String,
                  Struct->Name.Length, Struct->Name.String);


    WriteToOutput(Definitions, Memory,
                  "u32 PushJson(char *Json, u32 MaxLength, char const*Tag, const %.*s &Value, u32 JsonFlags = 0)\n{\n"
                  "    u32 Length = 0;\n"
                  "    b8 isLast = (JsonFlags & JSON_IsLastInList);\n"
                  "    if(JsonFlags & JSON_BaseObject)\n"
                  "    {\n"
                  "        Json[Length++] = '{';\n"
                  "    }\n"
                  "    if(!(JsonFlags & JSON_DontUseTag))\n"
                  "    {\n"
                  "          Length += stbsp_snprintf(&Json[Length], MaxLength, \"\\\"%%s\\\":\", Tag);\n"
                  "    }\n"
                  "    Length += StartGroup(&Json[Length], (MaxLength - Length));\n",
                  Struct->Name.Length, Struct->Name.String);

    const u32 MaxSectionSize = (1024ULL * (20));
    char *ExistListScratch = (char*)abm_PushSize_(Memory, MaxSectionSize);
    u32 ExistListCount = 0;
    ExistListCount += stbsp_snprintf(ExistListScratch, (MaxSectionSize - ExistListCount),
                                     "struct %.*s_existlist\n{\n", Struct->Name.Length, Struct->Name.String);


    term_structitem *StructItem = Struct->ItemListSentinal.Next;
    while(StructItem != &Struct->ItemListSentinal)
    {
        b8 isLast = (StructItem->Next == &Struct->ItemListSentinal);

        term_typeexpr *Item = StructItem->Type;

        ExistListCount += stbsp_snprintf(&ExistListScratch[ExistListCount], (MaxSectionSize - ExistListCount),
                                         "   b8 %.*s;\n", Item->Name.Length, Item->Name.String);

        const char *isLastString = (isLast) ? "JSON_IsLastInList" : "JSON_Null";
        char Separator = (!isLast) ? ',' : ' ';

        if(Item->isArray && abs_AreStringsEqual(Item->Type, "char"))
        {
            WriteToOutput(Definitions, Memory,
                          "{\nsize_t StringLen = abs_StringLength(Value.%.*s, %d);\n",
                          Item->Name.Length, Item->Name.String,
                          Item->ArrayLength);

            WriteToOutput(Definitions, Memory,
                          "Length += stbsp_snprintf(&Json[Length], (MaxLength - Length), \"\\\"%.*s\\\":\\\"%%.*s\\\"%c\", (s32)StringLen, Value.%.*s);\n}\n",
                          Item->Name.Length, Item->Name.String,
                          Separator,
                          Item->Name.Length, Item->Name.String
                          );
        }
        else if(!Item->isArray)
        {
            auto WriteFormatType = [&Definitions, &Memory, &Item, &Separator](char const *Format, b8 isPtr) -> void
            {
                if(isPtr)
                {
                    WriteToOutput(Definitions, Memory,
                                  "if(Value.%.*s)\n"
                                  "{\n    ",
                                  Item->Name.Length, Item->Name.String
                                  );
                }
                WriteToOutput(Definitions, Memory,
                              "Length += stbsp_snprintf(&Json[Length], (MaxLength - Length), \"\\\"%.*s\\\":%s%c\", %c(Value.%.*s));\n",
                              Item->Name.Length, Item->Name.String,
                              Format, Separator,
                              isPtr ? '*' : ' ',
                              Item->Name.Length, Item->Name.String
                              );

                if(isPtr)
                {
                    WriteToOutput(Definitions, Memory,
                                  "}\n");
                }
            };

            if(abs_AreStringsEqual(Item->Type, "u64"))
            {
                WriteFormatType("%llu", Item->isPtr);
            }
            else if(abs_AreStringsEqual(Item->Type, "s64"))
            {
                WriteFormatType("%lld", Item->isPtr);
            }
            else if(abs_AreStringsEqual(Item->Type, "u32") ||
                    abs_AreStringsEqual(Item->Type, "u16") ||
                    abs_AreStringsEqual(Item->Type, "u8"))

            {
                WriteFormatType("%u", Item->isPtr);
            }
            else if(abs_AreStringsEqual(Item->Type, "s32") ||
                    abs_AreStringsEqual(Item->Type, "s16") ||
                    abs_AreStringsEqual(Item->Type, "s8") ||
                    abs_AreStringsEqual(Item->Type, "int") ||
                    abs_AreStringsEqual(Item->Type, "long"))

            {
                WriteFormatType("%d", Item->isPtr);
            }
            else if(abs_AreStringsEqual(Item->Type, "char") && !Item->isPtr)
            {
                WriteFormatType("%d", Item->isPtr);
            }
            else if(abs_AreStringsEqual(Item->Type, "r32"))

            {
                WriteFormatType("%0.3f", Item->isPtr);
            }
            else if(abs_AreStringsEqual(Item->Type, "char") && Item->isPtr)
            {
                WriteToOutput(Definitions, Memory,
                              "if(Value.%.*s)\n"
                              "{\n",
                              Item->Name.Length, Item->Name.String
                              );

                WriteToOutput(Definitions, Memory,
                              "Length += stbsp_snprintf(&Json[Length], (MaxLength - Length), \"\\\"%.*s\\\":\\\"%%s\\\"%c\", (Value.%.*s));\n}\n",
                              Item->Name.Length, Item->Name.String,
                              Separator,
                              Item->Name.Length, Item->Name.String
                              );
            }
            else if(abs_AreStringsEqual(Item->Type, "abs_stringptr") && !Item->isPtr)
            {
                WriteToOutput(Definitions, Memory,
                              "if(Value.%.*s.String)\n"
                              "{\n",
                              Item->Name.Length, Item->Name.String
                              );

                WriteToOutput(Definitions, Memory,
                              "Length += stbsp_snprintf(&Json[Length], (MaxLength - Length), \"\\\"%.*s\\\":\\\"%%.*s\\\"%c\", (Value.%.*s.String), (Value.%.*s.String));\n}\n",
                              Item->Name.Length, Item->Name.String,
                              Separator,
                              Item->Name.Length, Item->Name.String,
                              Item->Name.Length, Item->Name.String
                              );
            }
            else if(abs_AreStringsEqual(Item->Type, "abs_stringptr") && Item->isPtr)
            {}
            else if(abs_AreStringsEqual(Item->Type, "b8"))
            {

                WriteToOutput(Definitions, Memory,
                              "Length += stbsp_snprintf(&Json[Length], (MaxLength - Length), \"\\\"%.*s\\\":%%s%c\", (%c(Value.%.*s) ? \"true\" : \"false\"));\n",
                              Item->Name.Length, Item->Name.String,
                              Separator,
                              Item->isPtr ? '*' : ' ',
                              Item->Name.Length, Item->Name.String
                              );
            }
            else
            {
                if(Item->isPtr)
                {
                    WriteToOutput(Definitions, Memory,
                                  "if(Value.%.*s)\n"
                                  "{\n    ",
                                  Item->Name.Length, Item->Name.String
                                  );
                }

                WriteToOutput(Definitions, Memory,
                              "Length += PushJson(&Json[Length], (MaxLength - Length), \"%.*s\", %c(Value.%.*s), %s);\n",
                              Item->Name.Length, Item->Name.String,
                              Item->isPtr ? '*' : ' ',
                              Item->Name.Length, Item->Name.String,
                              isLastString);
                if(Item->isPtr)
                {
                    WriteToOutput(Definitions, Memory,
                                  "}\n");
                }
            }
        }

        StructItem = StructItem->Next;
    }

    WriteToOutput(Definitions, Memory,
                  "    Length += EndGroup(&Json[Length], (MaxLength - Length), isLast);\n"
                  "    if(JsonFlags & JSON_BaseObject)\n"
                  "    {\n"
                  "        Json[Length++] = '}';\n"
                  "    }\n"
                  "    return Length;\n}\n\n");


    ExistListCount += stbsp_snprintf(&ExistListScratch[ExistListCount], (MaxSectionSize - ExistListCount),
                                     "};\n");


    WriteToOutput(Definitions, Memory,
                  "jsmntok_t *JsonToObject(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, jsmntok_t *TokenArray, %.*s *ObjectOut, %.*s_existlist *ItemsExistOut)\n"
                  "{\n"
                  "    %.*s_existlist* ItemExists = abm_PushStruct(VolatileMemory, %.*s_existlist);\n"
                  "    s32 NumTokensProcessed =  ParseJson(VolatileMemory, Json, JsonLength, &TokenArray);\n"
                  "    jsmntok_t *Token = TokenArray;\n"
                  "    if(Token)\n"
                  "    {\n"
                  "        s32 NumTokensToProcess = Token->size;\n"
                  "        s32 ObjectEndPosition = Token->end;\n"
                  "        for(s32 Index = 0; Index < NumTokensToProcess; ++Index)\n"
                  "        {\n"
                  "            ++Token;\n"
                  "            s32 TokenLength = Token->end - Token->start;\n"
                  "            \n",
                  Struct->Name.Length, Struct->Name.String,
                  Struct->Name.Length, Struct->Name.String,
                  Struct->Name.Length, Struct->Name.String,
                  Struct->Name.Length, Struct->Name.String);

    auto WriteIf = [&Definitions, &Memory](term_typeexpr *Item, char const *Type) -> void
    {
        WriteToOutput(Definitions, Memory,
                      "            if((abs_AreStringsEqual(&Json[Token->start], TokenLength, \"%.*s\",(ArrayCount(\"%.*s\")-1), true)) && \n"
                      "               ((Token+1)->type == %s)",
                      Item->Name.Length, Item->Name.String,
                      Item->Name.Length, Item->Name.String,
                      Type);

        if(Item->isPtr)
        {
            WriteToOutput(Definitions, Memory,
                          "&& \n"
                          "(ObjectOut->%.*s)",
                          Item->Name.Length, Item->Name.String
                          );
        }

        WriteToOutput(Definitions, Memory,
                      ") \n");
        WriteToOutput(Definitions, Memory,
                      "{\n            ItemExists->%.*s = true;\n",
                      Item->Name.Length, Item->Name.String);
    };

    StructItem = Struct->ItemListSentinal.Next;
    while(StructItem != &Struct->ItemListSentinal)
    {
        b8 isLast = (StructItem->Next == &Struct->ItemListSentinal);
        term_typeexpr *Item = StructItem->Type;

        if(!Item->isConst)
        {
            if(abs_AreStringsEqual(Item->Type, "u64") ||
               abs_AreStringsEqual(Item->Type, "s64"))
            {
                WriteIf(Item, "JSMN_PRIMITIVE");
                WriteToOutput(Definitions, Memory,
                              "    ++Token;\n"
                              "    %c(ObjectOut->%.*s) = (%.*s)atoll(&Json[Token->start]);\n"
                              "}\n\n",
                              Item->isPtr ? '*' : ' ',
                              Item->Name.Length, Item->Name.String,
                              Item->Type.Length, Item->Type.String);
            }
            else if(abs_AreStringsEqual(Item->Type, "u32") ||
                    abs_AreStringsEqual(Item->Type, "u16") ||
                    abs_AreStringsEqual(Item->Type, "u8") ||
                    abs_AreStringsEqual(Item->Type, "u32") ||
                    abs_AreStringsEqual(Item->Type, "u16") ||
                    abs_AreStringsEqual(Item->Type, "u8"))
            {
                WriteIf(Item, "JSMN_PRIMITIVE");
                WriteToOutput(Definitions, Memory,
                              "    ++Token;\n"
                              "    %c(ObjectOut->%.*s) = (%.*s)atoi(&Json[Token->start]);\n"
                              "}\n\n",
                              Item->isPtr ? '*' : ' ',
                              Item->Name.Length, Item->Name.String,
                              Item->Type.Length, Item->Type.String);
            }

            else if(abs_AreStringsEqual(Item->Type, "b8"))
            {
                WriteIf(Item, "JSMN_PRIMITIVE");
                WriteToOutput(Definitions, Memory,
                              "    ++Token;\n"
                              "    %c(ObjectOut->%.*s) = (strncmp(&Json[Token->start],\"true\",4) == 0);\n"
                              "}\n\n",
                              Item->isPtr ? '*' : ' ',
                              Item->Name.Length, Item->Name.String);
            }

            else if(abs_AreStringsEqual(Item->Type, "r32"))
            {
                WriteIf(Item, "JSMN_PRIMITIVE");
                WriteToOutput(Definitions, Memory,
                              "    ++Token;\n"
                              "    %c(ObjectOut->%.*s) = (%.*s)atof(&Json[Token->start]);\n"
                              "}\n\n",
                              Item->isPtr ? '*' : ' ',
                              Item->Name.Length, Item->Name.String,
                              Item->Type.Length, Item->Type.String);
            }

            else if(abs_AreStringsEqual(Item->Type, "char") && Item->isArray && !Item->isPtr)
            {
                WriteIf(Item, "JSMN_STRING");
                WriteToOutput(Definitions, Memory,
                              "    ++Token;\n"
                              "    TokenLength = Token->end - Token->start;\n"
                              "    s32 Length = MINIMUM(TokenLength, (%d-1));\n"
                              "    strncpy(ObjectOut->%.*s, &Json[Token->start], Length);\n"
                              "    ObjectOut->%.*s[Length] = 0;\n"
                              "}\n\n",
                              Item->ArrayLength,
                              Item->Name.Length, Item->Name.String,
                              Item->Name.Length, Item->Name.String
                              );
            }
            else if(abs_AreStringsEqual(Item->Type, "char") && Item->isPtr)
            {

            }

            else
            {



                WriteToOutput(Definitions, Memory,
                              "            if((abs_AreStringsEqual(&Json[Token->start], TokenLength, \"%.*s\",(ArrayCount(\"%.*s\")-1), true)) && \n"
                              "               (((Token+1)->type == JSMN_STRING) || ((Token+1)->type == JSMN_OBJECT))",
                              Item->Name.Length, Item->Name.String,
                              Item->Name.Length, Item->Name.String);
                if(Item->isPtr)
                {
                    WriteToOutput(Definitions, Memory,
                                  "&& \n"
                                  "(ObjectOut->%.*s)",
                                  Item->Name.Length, Item->Name.String
                                  );
                }

                WriteToOutput(Definitions, Memory,
                              ") \n");
                WriteToOutput(Definitions, Memory,
                              "{\n            ItemExists->%.*s = true;\n",
                              Item->Name.Length, Item->Name.String);

                WriteToOutput(Definitions, Memory,
                              "Token = JsonToObject(VolatileMemory, Json, JsonLength, ++Token,  %cObjectOut->%.*s,0);\n"
                              "}\n\n",
                              Item->isPtr ? ' ' : '&',
                              Item->Name.Length, Item->Name.String
                              );
            }
        }
        StructItem = StructItem->Next;
    }

    WriteToOutput(Definitions, Memory,
                  "\n}\n}\n");

    WriteToOutput(Definitions, Memory,
                  "if(ItemsExistOut)\n"
                  "{\n"
                  "    *ItemsExistOut = *ItemExists;\n"
                  "}\n");
    WriteToOutput(Definitions, Memory,
                  "return Token;\n}\n\n");


    WriteToOutput(Definitions, Memory,
                  "u32\n"
                  "JsonArrayToObjectArray(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, %.*s **ObjectArray, %.*s_existlist **ObjectArrayExists)\n"
                  "{\n"
                  "   u32 NumberOfObjects = 0;\n"
                  "            \n"
                  "    jsmntok_t *TokenArray = 0;\n"
                  "    s32 NumTokensParsed = ParseJson(VolatileMemory, Json, JsonLength, &TokenArray);\n"
                  "    \n"
                  "    if(TokenArray)\n"
                  "    {\n"
                  "        u32 TokenIndex = 0;\n"
                  "        jsmntok_t *Token = &TokenArray[TokenIndex++];\n"
                  "        if(Token->type == JSMN_OBJECT)\n"
                  "        {\n"
                  "            // NOTE(Amos): Next token will be a string; not checking label strings yet.\n"
                  "            ++TokenIndex;\n"
                  "            Token = &TokenArray[TokenIndex++];\n"
                  "        }\n"
                  "        \n"
                  "        if(Token->type == JSMN_ARRAY)\n"
                  "        {\n"
                  "            NumberOfObjects= Token->size;\n"
                  "            ++Token;\n"
                  "        }\n"
                  "        else if(Token->type == JSMN_OBJECT)\n"
                  "        {\n"
                  "            NumberOfObjects = 1;\n"
                  "        }\n"
                  "        \n"
                  "        if (!(*ObjectArray))\n"
                  "        {\n"
                  "            *ObjectArray = abm_PushArray(VolatileMemory, NumberOfObjects, %.*s);\n"
                  "        }\n"
                  "        if (!(*ObjectArrayExists))\n"
                  "        {\n"
                  "            *ObjectArrayExists = abm_PushArray(VolatileMemory, NumberOfObjects, %.*s_existlist);\n"
                  "        }\n"

                  "        \n"
                  "        for(u32 Index = 0; Index < NumberOfObjects; ++Index)\n"
                  "        {\n"
                  "            Token = JsonToObject(VolatileMemory, Json, JsonLength, Token, &(*ObjectArray)[Index],&(*ObjectArrayExists)[Index]);\n"
                  "            ++Token;\n"
                  "        }\n"
                  "    }\n"
                  "    return NumberOfObjects;\n"
                  "}\n",
                  Struct->Name.Length, Struct->Name.String,
                  Struct->Name.Length, Struct->Name.String,
                  Struct->Name.Length, Struct->Name.String,
                  Struct->Name.Length, Struct->Name.String);

    CopyToOutput(Headers, Memory, ExistListScratch);
}

void
ProcessStructs(term_struct *StructListSentinal, memory_arena *Memory, output_data *Headers, output_data *Definitions)
{
    term_struct *Struct = StructListSentinal->Next;
    while(Struct != StructListSentinal)
    {
        WriteToOutput(Headers, Memory,
                      "/****** Struct %.*s Header *****/\n",
                      Struct->Name.Length, Struct->Name.String);

        WriteToOutput(Headers, Memory,
                      "struct %.*s;\n",
                      Struct->Name.Length, Struct->Name.String);

        WriteToOutput(Definitions, Memory,
                      "/****** Struct %.*s Functions *****/\n", Struct->Name.Length, Struct->Name.String);

        tag *Tag = Struct->TagListSentinal.Next;
        while(Tag != &Struct->TagListSentinal)
        {
            if(abs_AreStringsEqual(Tag->Name, "JSON"))
            {
                CreateStructJson(Struct, Tag, Memory, Headers, Definitions);
            }

            Tag = Tag->Next;
        }

        WriteToOutput(Headers, Memory, "\n");
        WriteToOutput(Definitions, Memory, "\n");

        Struct = Struct->Next;
    }
}
# 111 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp" 2

output_data *
GenerateOutput(memory_arena *Memory, char const *OutputFile, output_data *Header, output_data *Definition)
{
    ;
    output_data *FullOutput = (output_data*)abm_PushSize_(Memory, sizeof(output_data));
    abs_stringptr CapitalizedOutput = abs_Capitalize(OutputFile, Memory);


    for(u32 i = 0; i < CapitalizedOutput.Length; ++i)
    {
        char *C = (char*)&CapitalizedOutput.String[i];
        if((*C < 0x30) ||
           (*C > 0x39 && *C < 0x41) ||
           (*C > 0x5A && *C < 0x61) ||
           (*C > 0x7A))
        {
            *C = '_';
        }
    }
    WriteToOutput(FullOutput, Memory, "%s\n", GeneratedTag);

    WriteToOutput(FullOutput, Memory,
                  "/** \n"
                  "    Code Generator Version: " "1.0" "\n\n"
                  "    This file was autogenerated. Do not edit directly, your changes will get over-written. \n"
                  "    This is a single file include. To include the source, add \n\n"
                  "#define %.*s_SRC\n\n"
                  "    before including this this file.\n\n"
                  "    If you are using JSON parsing, add \n\n"
                  "#define GEN_JSMN_HEADER\n\n"
                  "    Ensure the jsmn.h header is in your include directory.\n"
                  "**/\n\n"
                  "#ifndef TAG\n"
                  "#define TAG(...)\n"
                  "#endif\n\n"
                  "#ifndef STATEMACHINE\n"
                  "#define STATEMACHINE(...)\n"
                  "#endif\n"
                  "#include <stdlib.h>\n"
                  "#include \"ab_memory.h\"\n"
                  "#include \"ab_string.h\"\n"
                  "#include \"stb_sprintf.h\""
                  "\n"
                  "#ifdef GEN_JSMN_HEADER\n"
                  "#include \"jsmn.h\"\n"
                  "#endif // GEN_JSMN_HEADER\n\n"
                  "\n",
                  CapitalizedOutput.Length, CapitalizedOutput.String);


    {
        WriteToOutput(FullOutput, Memory,
                      "#if !defined(_GENERATED_HEADER_)\n#define _GENERATED_HEADER_\n");

        WriteToOutput(FullOutput, Memory,
                      "#ifdef GEN_JSMN_HEADER\n"
                      "enum json_flags\n"
                      "{\n"
                      "    JSON_Null = 0,\n"
                      "    JSON_IsLastInList = 1 << 0,\n"
                      "    JSON_DontUseTag = 1 << 1,\n"
                      "    JSON_BaseObject = 1 << 2,\n"
                      "};\n"
                      "#endif\n\n"
                      );

        WriteToOutput(FullOutput, Memory, "template<typename T>\n"
                      "auto StringToEnum(const char *String) -> T;\n\n");

        WriteToOutput(FullOutput, Memory, "template<typename T>\n"
                      "auto StringToEnum(abs_stringptr String) -> T;\n\n");

        WriteToOutput(FullOutput, Memory, "u32 StartGroup(char *, u32 MaxLength);\n");
        WriteToOutput(FullOutput, Memory, "u32 EndGroup(char *, u32 MaxLength, b8 isLast);\n");
        WriteToOutput(FullOutput, Memory,
                      "#ifdef GEN_JSMN_HEADER\n"
                      "s32 ParseJson(memory_arena *VolatileMemory, char const *Json,  size_t JsonLength, jsmntok_t **TokenArray);\n"
                      "#endif\n\n"
                      );

        WriteToOutput(FullOutput, Memory, "#endif\n\n");
    }



    WriteToOutput(FullOutput, Memory,
                  "#if !defined(_AB_GENERATED_HEADER_%.*s_)\n#define _AB_GENERATED_HEADER_%.*s_\n\n",
                  CapitalizedOutput.Length, CapitalizedOutput.String, CapitalizedOutput.Length, CapitalizedOutput.String);

    CopyToOutput(FullOutput, Memory, Header);

    WriteToOutput(FullOutput, Memory,
                  "#endif // _AB_GENERATED_HEADER_%.*s_\n\n",
                  CapitalizedOutput.Length, CapitalizedOutput.String);

    WriteToOutput(FullOutput, Memory,
                  "#if defined(%.*s_SRC)\n#undef %.*s_SRC\n\n"
                  ,
                  CapitalizedOutput.Length, CapitalizedOutput.String, CapitalizedOutput.Length, CapitalizedOutput.String);

    WriteToOutput(FullOutput, Memory,
                  "#if !defined(_GENERATED_SRC_)\n"
                  "#define _GENERATED_SRC_\n"
                  "\n"
                  "#define STB_SPRINTF_IMPLEMENTATION\n"
                  "#include \"stb_sprintf.h\"\n"
                  "#undef STB_SPRINTF_IMPLEMENTATION\n\n"
                  "#ifdef GEN_JSMN_HEADER\n\n"
                  "inline s32\n"
                  "ParseJson(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, jsmntok_t **TokenArray)\n"
                  "{\n"
                  "    s32 NumTokensProcessed = 0;\n"
                  "    if(!(*TokenArray))\n"
                  "    {\n"
                  "        jsmn_parser Parser;\n"
                  "        jsmn_init(&Parser);\n"
                  "        s32 NumTokensExisting = jsmn_parse(&Parser, Json, JsonLength, NULL, 0);\n"
                  "        if(NumTokensExisting > 0)\n"
                  "        {\n"
                  "            // NOTE(amos): The last token will always be an undefined, so we can use it\n"
                  "            //     to find the end of the token array.\n"
                  "            *TokenArray = abm_PushArray(VolatileMemory, (NumTokensExisting+1), jsmntok_t);\n"
                  "            jsmn_init(&Parser);\n"
                  "            NumTokensProcessed = jsmn_parse(&Parser, Json, JsonLength, *TokenArray, NumTokensExisting);\n"
                  "        }\n"
                  "    }\n"
                  "    else\n"
                  "    {\n"
                  "        NumTokensProcessed = (*TokenArray)->size;\n"
                  "    }\n"
                  "    \n"
                  "    return NumTokensProcessed;\n"
                  "}\n"
                  "\n"
                  "inline u32\n"
                  "StartGroup(char *Json, u32 MaxLength)\n"
                  "{\n"
                  "    u32 Length = 0;\n"
                  "    if (MaxLength >= 1)\n"
                  "    {\n"
                  "        Json[0] = '{';\n"
                  "        ++Length;\n"
                  "    }\n"
                  "    \n"
                  "    return Length;\n"
                  "}\n"
                  "\n"
                  "inline u32\n"
                  "EndGroup(char *Json, u32 MaxLength, b8 isLast = false)\n"
                  "{\n"
                  "    u32 Length = 0;\n"
                  "    if(isLast && MaxLength >= 1)\n"
                  "    {\n"
                  "        Json[0] = '}';\n"
                  "        ++Length;\n"
                  "    }\n"
                  "    else if(!isLast && MaxLength >= 2)\n"
                  "    {\n"
                  "        Json[0] = '}';\n"
                  "        Json[1] = ',';\n"
                  "        Length += 2;\n"
                  "    }\n"
                  "    \n"
                  "    return Length;\n"
                  "}\n"
                  "\n"
                  "inline abs_stringptr\n"
                  "TokenToStringPtr(char const *Json, jsmntok_t *Token)\n"
                  "{\n"
                  "    abs_stringptr Result;\n"
                  "    Result.String = &Json[Token->start];\n"
                  "    Result.Length = (Token->end-Token->start);\n"
                  "    \n"
                  "    return Result;\n"
                  "}\n"
                  "\n"
                  "inline b8\n"
                  "TokenEquals(char const* Json, jsmntok_t *Token, char const* Value)\n"
                  "{\n"
                  "    u32 TokenLength = Token->end-Token->start;\n"
                  "    b8 Result =\n"
                  "        abs_AreStringsEqual(&Json[Token->start], TokenLength, Value, abs_StringLength(Value, TokenLength), true);\n"
                  "    \n"
                  "    return Result;\n"
                  "}\n"
                  "\n"
                  "#endif\n"
                  "\n"
                  "#endif\n"
                  );

    CopyToOutput(FullOutput, Memory, Definition);


    WriteToOutput(FullOutput, Memory,
                  "#endif // %.*s_SRC\n",
                  CapitalizedOutput.Length, CapitalizedOutput.String);

    return FullOutput;
}


inline void
CreateFullFilename(char *Output, size_t MaxLength, char const *Path, u32 Number)
{
    char const *OutputHeaderFileTemplate = "Generated_";
    stbsp_snprintf(Output, MaxLength, "%s/%s%03d.h", Path, OutputHeaderFileTemplate, Number);
}

void
WriteOutputToFile(output_data *OutputData, char const *SourceDirectory, char const *OutputFile)
{
    if(OutputData)
    {
        char GeneratedFilename[255];
        stbsp_snprintf(GeneratedFilename, (sizeof(GeneratedFilename)) / (sizeof(GeneratedFilename[1])), "%s/%s.h",
                       SourceDirectory, OutputFile);
        output_data *OutputDataPtr = OutputData;
        FILE *GeneratedFile = fopen(GeneratedFilename, "w");
        while(OutputDataPtr)
        {
            fwrite(OutputDataPtr->OutputString, 1, OutputDataPtr->Used, GeneratedFile);
            fflush(GeneratedFile);
            OutputDataPtr = OutputDataPtr->Next;
        }
        fclose(GeneratedFile);
    }
}


void
WriteOutputToStdOut(output_data *OutputData)
{
    if(OutputData)
    {
        output_data *OutputDataPtr = OutputData;
        while(OutputDataPtr)
        {
            fwrite(OutputDataPtr->OutputString, 1, OutputDataPtr->Used, 
# 350 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp" 3 4
                                                                       stdout
# 350 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp"
                                                                             );
            fflush(
# 351 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp" 3 4
                  stdout
# 351 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp"
                        );

            OutputDataPtr = OutputDataPtr->Next;
        }
    }
    else
    {
        printf("No output data to print.");
    }
    printf("\n\n");
}

int
main(int argc, char** argv)
{

    if(argc <= 1)
    {
        fprintf(
# 369 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp" 3 4
               stderr
# 369 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp"
                     , "No directories to process. Specify desired directory to process on the command line.\n");
        fprintf(
# 370 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp" 3 4
               stderr
# 370 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp"
                     , "You may also specify an output filename (excluding the extension). If no filename is given, "
                "the output will be sent to stdout.\n");
        fprintf(
# 372 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp" 3 4
               stderr
# 372 "/home/amos/prog/c/amos_libraries/preprocessor/ab_preprocessor2.cpp"
                     , "%s <dir> [<outputfile>]\n", argv[0]);
        return 1;
    }
    b8 isFileOutput = false;
    char const *OutputFile = 0;
    if(argc == 3)
    {
        isFileOutput = true;
        OutputFile = argv[2];
    }
    else
    {
        OutputFile = "GENERATED_OUTPUT";
    }

    size_t Size = (1024ULL * (1024ULL * (1024ULL * (1))));
    void *MemoryPtr = abm_AllocateOsMemory(0, Size);
    memory_arena Memory = abm_InitMemory(MemoryPtr, Size);

    const s32 LexerStoreLength = (1024ULL * (65));
    void* LexerStore = abm_PushSize_(&Memory, LexerStoreLength);

    lexer Lexer = {};

    {
        char const *SourceDirectory = argv[1];
        temporary_memory TempMem = abm_BeginTemporaryMemory(&Memory);
        output_data *HeaderOutput = (output_data*)abm_PushSize_(&Memory, sizeof(output_data));
        output_data *DefinitionOutput = (output_data*)abm_PushSize_(&Memory, sizeof(output_data));


        file_list *FileList = abf_InitializeFileList(&Memory, SourceDirectory);
        file_data File;
        while(abf_GetNextFile(FileList, &File))
        {
            if(abs_AreStringFragmentsEqual(GeneratedTag, File.FileData, abs_StringLength(GeneratedTag, 40), false))
            {
                continue;
            }
            abl_InitLexer(&Lexer, &File);

            parser *Parser = ParseInit(&Memory);
            ParseExpr(&Lexer, Parser);

            ProcessEnums(&Parser->EnumListSentinal, &Memory, HeaderOutput, DefinitionOutput);
            ProcessStateFunctions(&Parser->StateMachineListSentinal, &Parser->DefinedFunctionListSentinal,
                                  &Memory, HeaderOutput, DefinitionOutput);
            ProcessStructs(&Parser->StructListSentinal, &Memory, HeaderOutput, DefinitionOutput);
        }

        output_data *OutputData = GenerateOutput(&Memory, OutputFile, HeaderOutput, DefinitionOutput);

        if(isFileOutput)
        {
            WriteOutputToFile(OutputData, SourceDirectory, OutputFile);
        }
        else
        {
            WriteOutputToStdOut(OutputData);
        }

        abf_ReleaseFileList(FileList);
        abm_EndTemporaryMemory(TempMem);
    }

    return 0;
}
