/* *  GENERATED   * */
/** @file 
@brief Generated source file.
@author Automatically Generated from Amos Buchanan Preprocessor.
@version Code Generator Version 1.0
@date Sep 2020

This file was autogenerated. Do not edit directly, your changes will get over-written. 
This is a single file include. To include the source, add 

~~~c
#define GENERATED_TEST_SRC
~~~

This source depends on `stb_sprintf.h`. The source must be included somewhere; it's not pulled in automatically. This header is one of [Sean T Barrett's single-header libraries, available on github](https://github.com/nothings/stb).
To add the source, add the following defines ONCE:

~~~c
#define STB_SPRINTF_IMPLEMENTATION
#include "stb_sprintf.h"
#undef STB_SPRINTF_IMPLEMENTATION
~~~

JSON parsing is handled by [JSMN library, available on github](https://github.com/zserge/jsmn). If you are not using any JSON tags, this library is not needed. If you *are* using JSON parsing, add the following line before including this file.
~~~c
#define GEN_JSMN_HEADER
~~~

Ensure the jsmn.h header is in your include directory. You will have to include the source code yourself separately.

The code is marked using doxygen. By default, it excludes the JSON parsing functions. If you'd like to include them, add `GEN_JSMN_HEADER` to the option in doxygen.cfg. Example:
~~~
PREDEFINED = GEN_JSMN_HEADER
~~~

**/

#ifndef TAG
#define TAG(...)
#endif

#ifndef STATEMACHINE
#define STATEMACHINE(...)
#endif
#include <stdlib.h>
#include "ab_memory.h"
#include "ab_string.h"
#include "stb_sprintf.h"
#ifdef GEN_JSMN_HEADER
#include "ab_json.h"
#endif // GEN_JSMN_HEADER


#if !defined(_GENERATED_HEADER_)
#define _GENERATED_HEADER_
/** @brief Generic template for the c-style string StringToEnum<> functions. **/
template<typename T>
auto StringToEnum(const char *String) -> T;

/** @brief Generic template for the abs_stringptr StringToEnum<> functions. **/
template<typename T>
auto StringToEnum(abs_stringptr String) -> T;


#endif

#if !defined(_AB_GENERATED_HEADER_GENERATED_TEST_)
#define _AB_GENERATED_HEADER_GENERATED_TEST_

/****  StateMachine: TEST_STATEMACHINE ****/
struct test_type;
enum class test_cmd;
/***** Queue: test_cmd ****/
/** @brief A circular queue of 10 elements for the state command test_cmd. */
struct test_cmd_queue
{
    test_cmd Items[10];
    s32 Front;
    s32 Rear;
};

/** @brief Initialize the command queue.

This must be run to initialize the queue before it may be used for the first time. Usually done in the state machine 
initialization.

@param Queue The queue to initialize, usually `&State->CommandQueue`.
**/
inline void InitializeQueue(test_cmd_queue *Queue);
/** @brief Check if queue is empty.

@param Queue Queue to check.
@return True if queue is empty.
**/
inline b8 isQueueEmpty(test_cmd_queue *Queue);
/** @brief Check if queue is full.

@param Queue Queue to check.
@return True if queue is full.
**/
inline b8 isQueueFull(test_cmd_queue *Queue);
/** @brief Add an item to the back of the queue.

@param Queue The queue to add to.
@param The command to add.
@return True if successful.
**/
b8 EnqueueCommand(test_cmd_queue *Queue, test_cmd Cmd);
/** @brief Dequeue from the front of the queue.

@param The queue to pull a command from.
@return The command that was queued. If the queue is empty, returns the first element of test_cmd. The first element is usually reserved for a NOP command.
**/
test_cmd DequeueCommand(test_cmd_queue *Queue);
/***********/

/** @brief Used to create statemachine functions.
 Usage:
~~~c
TEST_STATEMACHINE(FuntionForState)
{
    // Function Code
}
~~~

This expands out to the function signature: 
~~~c

void FunctionForState(test_type *State, test_cmd Cmd, int Int, char const *String)

~~~

The `test_type` struct must have the following basic definition. See @ref index for more details.

Usage:
~~~c
struct test_type 
{
    test_statemachine CurrentState;
    b8 isNewState;
    test_cmd_queue CommandQueue;

    // Rest of variables in struct
};
~~~

See @ref index for more details.
**/
#define TEST_STATEMACHINE(name) void name(test_type *State, test_cmd Cmd, int Int, char const *String)
/** @brief typedef to use in the state struct. **/
typedef TEST_STATEMACHINE(test_statemachine);

/** @brief Go to the state specified.

Use this function to go to the next state after this state has completed. If you call this multiple times in a function,
only the last target state will be used. It also sets up the next state. This function should be used for changing states.

@params State The state struct corresponding to this state.
@params NewState The function name of the target state, generated by `TEST_STATEMACHINE()`.
@return True if the state change was successful.
**/
inline b8 GoToState(test_type *State, test_statemachine *NewState);
/** @brief Gets a string representation of the state name.

This is usually used for logging or displaying to the user.

@param StateName The state to retrieve a string for, generated by `TEST_STATEMACHINE()`.
@return a null-terminated c string.
**/
char const *GetStateName(test_statemachine *StateName);
/** @brief Enqueue a command for the state.

@params State The state struct corresponding to this state.
@params Cmd The Cmd to enqueue.
**/
b8 EnqueueCommand(test_type *State, test_cmd Cmd);
/** @brief Dequeue the the command.

Corresponds to a first in, first out queue.
@params State The state struct corresponding to this state.
@return The first command in the queue..
**/
test_cmd DequeueCommand(test_type *State);

/** @brief Forward declaration for Idle(). **/
TEST_STATEMACHINE(Idle);
/** @brief Forward declaration for Running(). **/
TEST_STATEMACHINE(Running);

/*********/

/****** Enum test_cmd Header *****/
enum class test_cmd;
/** @brief Number of items in test_cmd enum. **/
const u32 test_cmd_Count = 6;
/** @brief Convert a char * c-style string to a test_cmd enum. 

If the string does not correspond to any of the enums, it will return the first value of the enum: `test_cmd::NOP`.

@param String A null terminated string
@return A test_cmd enum value.
**/
template<>
auto StringToEnum<test_cmd>(const char *String) -> test_cmd;
/** @brief Convert a abs_stringptr string to a test_cmd enum. 

If the string does not correspond to any of the enums, it will return the first value of the enum: `test_cmd::NOP`.

@param String An abs_stringptr string.
@return A test_cmd enum value.
**/
template<>
auto StringToEnum<test_cmd>(abs_stringptr String) -> test_cmd;
/** @brief Return a abs_stringptr corresponding for the given test_cmd enum.

@param EnumToken The enum to convert to a string.
@return A constant abs_stringptr.
**/
constexpr abs_stringptr EnumToString(test_cmd EnumToken);
/** @brief Return a const char* null-terminated string for the given test_cmd enum.

@param EnumToken The enum to convert to a string.
@return A null-terminated string
**/
constexpr char const* EnumToCString(test_cmd EnumToken);

/****** Enum enColours Header *****/
enum class enColours;
/** @brief Number of items in enColours enum. **/
const u32 enColours_Count = 3;
#ifdef GEN_JSMN_HEADER
/** @brief Convert a JSON string to a enColours enum.

This function converts a given JSON string to an enum. Most often, this is called while parsing a struct JSON string. Example:

~~~json
"{ "SomeTagName": "Red" }"
~~~

will set ObjectOut to `enColours::Red`. This function is usually called by the struct version of JsonToObject, rather than being called directly. 
if this enum is part of a struct.

This function relies on the `Strings` tag to do the String To Enum conversion.
@param VolatileMemory Memory that is used and is expected to be released elsewhere.
@param Json The JSON string to parse.
@param JsonLength The length of the Json String.
@param TokenArray Set to NULL. This is used when parsing JSON structs.
@param[out] ObjectOut This is the enum that was parsed.
@param Unused This input is ignored; it is used in parsing JSON structs.
@return Returns token array for the number of unused tokens in the JSON string.
**/
jsmntok_t *JsonToObject(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, jsmntok_t *TokenArray, enColours *ObjectOut, u32 Unused);
/** @brief Create a JSON string from a enColours enum.

This creates a JSON string from a given enum, in the form:

~~~json
{ "SomeTag":"Red" }
~~~

This function is usually called from the struct version JsonToObject. 

@param Json A string buffer to write the JSON to.
@param MaxLength The maximum length that may be written to the buffer.
@param Tag The tag or variable name to use for the JSON. (eg 'SomeTag')
@param Type The enum to convert to JSON.
@param JsonFlags Or'd list of flags. See @ref json_flags in @ref ab_json.h. 
@return Number of characters written to the buffer, not including the null character.
**/
u32 PushJson(char *Json, u32 MaxLength, char const *Tag, enColours Type, u32 JsonFlags);
#endif

/** @brief Convert a char * c-style string to a enColours enum. 

If the string does not correspond to any of the enums, it will return the first value of the enum: `enColours::Red`.

@param String A null terminated string
@return A enColours enum value.
**/
template<>
auto StringToEnum<enColours>(const char *String) -> enColours;
/** @brief Convert a abs_stringptr string to a enColours enum. 

If the string does not correspond to any of the enums, it will return the first value of the enum: `enColours::Red`.

@param String An abs_stringptr string.
@return A enColours enum value.
**/
template<>
auto StringToEnum<enColours>(abs_stringptr String) -> enColours;
/** @brief Return a abs_stringptr corresponding for the given enColours enum.

@param EnumToken The enum to convert to a string.
@return A constant abs_stringptr.
**/
constexpr abs_stringptr EnumToString(enColours EnumToken);
/** @brief Return a const char* null-terminated string for the given enColours enum.

@param EnumToken The enum to convert to a string.
@return A null-terminated string
**/
constexpr char const* EnumToCString(enColours EnumToken);
/** @brief Return a null-terminated string text for the defined label based on the enum.

Labels are defined as part of the enum definition, see [the readme](@ref index) for information on how to create the labels.

@param EnumToken The enum to convert.
@return A null-terminated const string.
**/
const char *EnumToLabel_Object(enColours EnumToken);
//const char * enColours_LabelObject[enColours_Count];

/****** Struct my_json_test Header *****/
struct my_json_test;
#ifdef GEN_JSMN_HEADER
/** @brief Convert a struct object into a JSON string.

Converts an object into a string. This can be a named variable in JSON or it can be part of an array depending on the JsonFlags.
The resulting JSON object uses the variable names for the tags. It supports basic types and arrays from @ref ab_common.h,
as well as any enum or struct also tagged with JSON.

@param Json The JSON string buffer to write to.
@param MaxLength The maximum characters to write to the buffer.
@param Tag The tag to use. Can be NULL if tag is not used. See JsonFlags.
@param Value The struct to convert, passed as a reference.
@param JsonFlags Or'd list of flags. See @ref json_flags in @ref ab_json.h.
@return The number of characters written to the buffer, not including the null character.
**/
u32 PushJson(char *Json, u32 MaxLength, char const *Tag, const my_json_test &Value, u32 JsonFlags);
/** @brief Returns whether a variable was specified in the JSON string when converting back to a struct. See @ref JsonToObject. **/struct my_json_test_existlist;
/** @brief Convert a JSON string to an object.

This takes a JSON string and converts it into an object. The tags in the JSON string correspond to the variable names in the struct.
Unknown tags are ignored. It will also descend into enums and structs also tagged as JSON.

@param VolatileMemory Memory that is used and is expected to be released elsewhere.
@param Json The JSON string to parse.
@param JsonLength The length of the Json String.
@param TokenArray Set to NULL. This is used when descending through structs.
@param[out] ObjectOut Location to put the struct information that is parsed.
@param[out] ItemsExistOut If the variable exists, the corresponding item in this struct will be set to true.
@return Returns token array for the number of unused tokens in the JSON string.
**/
jsmntok_t *JsonToObject(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, jsmntok_t *TokenArray, my_json_test *ObjectOut, my_json_test_existlist *ItemsExistOut);
/** @brief Convert a JSON string to an array of objects.

This takes a JSON string that consists of an array and converts it into an array of those objects. 
Each object is converted as per @ref JsonToObject.

@param VolatileMemory Memory that is used and is expected to be released elsewhere.
@param Json The JSON string to parse.
@param JsonLength The length of the Json String.
@param[out] ObjectArray Location to put the object array. Array memory is taken from VolatileMemory.
@param[out] ObjectArrayExist Array of my_json_test_existlist structs, as per @ref JsonToObject.
@return Number of items in the array.
**/
u32 JsonArrayToObjectArray(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, my_json_test **ObjectArray, my_json_test_existlist **ObjectArrayExist);
#endif

struct my_json_test_existlist
{
   b8 TestUnsigned;
   b8 TestString;
   b8 MyColour;
   b8 isValue;
};

#include "PreprocTest.h"

#endif // _AB_GENERATED_HEADER_GENERATED_TEST_

#if defined(GENERATED_TEST_SRC)
#undef GENERATED_TEST_SRC

/****** Queue: test_cmd ****/
inline void
InitializeQueue(test_cmd_queue *Queue)
{
  Queue->Front = Queue->Rear = -1;
}

inline b8
isQueueEmpty(test_cmd_queue *Queue)
{
  b8 Result = (Queue->Front == -1);
  return Result;
}

inline b8 
isQueueFull(test_cmd_queue *Queue)
{
  b8 Result = (Queue->Front == Queue->Rear + 1) ||
  (Queue->Front == 0 && Queue->Rear == (10-1));

  return Result;
}

b8
Enqueue(test_cmd_queue *Queue, test_cmd Cmd)
{
  b8 Result = false;
  if(!isQueueFull(Queue))
  {
    if(Queue->Front == -1)
    {
      Queue->Front = 0;
    }
    Queue->Rear = (Queue->Rear + 1) % 10;
    Queue->Items[Queue->Rear] = Cmd;

    Result = true;
  }
  return Result;    
}

test_cmd
Dequeue(test_cmd_queue *Queue)
{
test_cmd Result = (test_cmd)0;
if(!isQueueEmpty(Queue))
{
Result = Queue->Items[Queue->Front];
if(Queue->Front == Queue->Rear)
{
Queue->Front = Queue->Rear = -1;
}
else 
{
Queue->Front = (Queue->Front + 1) % 10;
}
}

return Result;
}

/***********/

/**** StateMachine: TEST_STATEMACHINE **/
// Function Definitions
inline b8
GoToState(test_type *State, test_statemachine *NewState)
{
    b8 isChanged = false;
    if(NewState && State)
    {
        State->CurrentState = NewState;
        State->isNewState = true;
    }

    return isChanged;
}

char const*
GetStateName(test_statemachine *StateName)
{
if(StateName == Idle) {return "Idle";}
if(StateName == Running) {return "Running";}
return "Unknown";
}

b8
EnqueueCommand(test_type *State, test_cmd Cmd)
{
return Enqueue(&State->CommandQueue, Cmd);
}

test_cmd
DequeueCommand(test_type *State)
{
return Dequeue(&State->CommandQueue);
}


/*********/

/****** Enum test_cmd Functions *****/
constexpr abs_stringptr test_cmd_Strings[test_cmd_Count] = 
{
   {"NOP", 3},
   {"Command1", 8},
   {"Command2", 8},
   {"Command3", 8},
   {"Command4", 8},
   {"Last", 4},
};

template<>
auto StringToEnum<test_cmd>(const char *String) -> test_cmd
{
    u32 StringIndex = abs_FindInList(String, test_cmd_Count, test_cmd_Strings, true);
    test_cmd Result = test_cmd::NOP;
    if(StringIndex < test_cmd_Count)
    {
        Result = static_cast<test_cmd>(StringIndex);
    }
    return Result;
}
template<>
auto StringToEnum<test_cmd>(abs_stringptr String) -> test_cmd
{
    u32 StringIndex = abs_FindInList(String, test_cmd_Count, test_cmd_Strings, true);
    test_cmd Result = test_cmd::NOP;
    if(StringIndex < test_cmd_Count)
    {
        Result = static_cast<test_cmd>(StringIndex);
    }
    return Result;
}
constexpr const char *
EnumToCString(test_cmd EnumToken)
{
    return test_cmd_Strings[int(EnumToken)].String;
}

constexpr abs_stringptr
EnumToString(test_cmd EnumToken)
{
    return test_cmd_Strings[int(EnumToken)];
}


/****** Enum enColours Functions *****/
#ifdef GEN_JSMN_HEADER
u32
PushJson(char *Json, u32 MaxLength, char const *Tag, enColours Type, u32 JsonFlags = 0)
{
    u32 Length = 0;
    b8 isLast = (JsonFlags & JSON_IsLastInList);
    Length += stbsp_snprintf(Json, MaxLength, "\"%s\":\"%s\"", Tag, EnumToCString(Type));
    if(!isLast) { Json[Length++] = ','; }
    return Length;
}

jsmntok_t *JsonToObject(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, jsmntok_t *TokenArray, enColours *ObjectOut, u32 Unused)
{
    enColours Result = static_cast<enColours>(0);
    s32 NumTokensUsed = 0;
    
    s32 TotalTokens = ParseJson(VolatileMemory, Json, JsonLength, &TokenArray);
    if(TokenArray)
    {
        s32 Index = 0;
        if((TokenArray[Index].type == JSMN_OBJECT) &&
           (TotalTokens > 1))
        {
            ++Index;
        }
        if(TokenArray[Index].type == JSMN_STRING)
        {
            s32 TokenLength = (TokenArray[Index].end - TokenArray[Index].start);
            abs_stringptr EnumString = {&Json[TokenArray[Index].start], TokenLength};
            Result = StringToEnum<enColours>(EnumString);
            NumTokensUsed = Index;
        }
        else 
        {
            NumTokensUsed = Index;
        }
    }
    *ObjectOut = Result;
    return TokenArray + NumTokensUsed;
}

#endif

constexpr abs_stringptr enColours_Strings[enColours_Count] = 
{
   {"Red", 3},
   {"Green", 5},
   {"Blue", 4},
};

template<>
auto StringToEnum<enColours>(const char *String) -> enColours
{
    u32 StringIndex = abs_FindInList(String, enColours_Count, enColours_Strings, true);
    enColours Result = enColours::Red;
    if(StringIndex < enColours_Count)
    {
        Result = static_cast<enColours>(StringIndex);
    }
    return Result;
}
template<>
auto StringToEnum<enColours>(abs_stringptr String) -> enColours
{
    u32 StringIndex = abs_FindInList(String, enColours_Count, enColours_Strings, true);
    enColours Result = enColours::Red;
    if(StringIndex < enColours_Count)
    {
        Result = static_cast<enColours>(StringIndex);
    }
    return Result;
}
constexpr const char *
EnumToCString(enColours EnumToken)
{
    return enColours_Strings[int(EnumToken)].String;
}

constexpr abs_stringptr
EnumToString(enColours EnumToken)
{
    return enColours_Strings[int(EnumToken)];
}

const char * enColours_LabelObject[enColours_Count] = 
{
    "Apple",
    "Brocoli",
    "Blueberry",
};

const char *
EnumToLabel_Object(enColours EnumToken)
{
    return enColours_LabelObject[int(EnumToken)];
}


/****** Struct my_json_test Functions *****/
#ifdef GEN_JSMN_HEADER
u32 PushJson(char *Json, u32 MaxLength, char const*Tag, const my_json_test &Value, u32 JsonFlags = 0)
{
    u32 Length = 0;
    b8 isLast = (JsonFlags & JSON_IsLastInList);
    if(JsonFlags & JSON_BaseObject)
    {
        Json[Length++] = '{';
    }
    if(!(JsonFlags & JSON_DontUseTag))
    {
          Length += stbsp_snprintf(&Json[Length], MaxLength, "\"%s\":", Tag);
    }
    Length += StartGroup(&Json[Length], (MaxLength - Length));
Length += stbsp_snprintf(&Json[Length], (MaxLength - Length), "\"TestUnsigned\":%u,",  (Value.TestUnsigned));
{
size_t StringLen = abs_StringLength(Value.TestString, 50);
Length += stbsp_snprintf(&Json[Length], (MaxLength - Length), "\"TestString\":\"%.*s\",", (s32)StringLen, Value.TestString);
}
Length += PushJson(&Json[Length], (MaxLength - Length), "MyColour",  (Value.MyColour), JSON_Null);
Length += stbsp_snprintf(&Json[Length], (MaxLength - Length), "\"isValue\":%s ", ( (Value.isValue) ? "true" : "false"));
    Length += EndGroup(&Json[Length], (MaxLength - Length), isLast);
    if(JsonFlags & JSON_BaseObject)
    {
        Json[Length++] = '}';
    }
    return Length;
}

jsmntok_t *JsonToObject(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, jsmntok_t *TokenArray, my_json_test *ObjectOut, my_json_test_existlist *ItemsExistOut)
{
    my_json_test_existlist* ItemExists = abm_PushStruct(VolatileMemory, my_json_test_existlist);
    s32 NumTokensProcessed =  ParseJson(VolatileMemory, Json, JsonLength, &TokenArray);
    jsmntok_t *Token = TokenArray;
    if(Token)
    {
        s32 NumTokensToProcess = Token->size;
        s32 ObjectEndPosition = Token->end;
        for(s32 Index = 0; Index < NumTokensToProcess; ++Index)
        {
            ++Token;
            s32 TokenLength = Token->end - Token->start;
            
            if((abs_AreStringsEqual(&Json[Token->start], TokenLength, "TestUnsigned",(ArrayCount("TestUnsigned")-1), true)) && 
               ((Token+1)->type == JSMN_PRIMITIVE)) 
{
            ItemExists->TestUnsigned = true;
    ++Token;
     (ObjectOut->TestUnsigned) = (u8)atoi(&Json[Token->start]);
}

            if((abs_AreStringsEqual(&Json[Token->start], TokenLength, "TestString",(ArrayCount("TestString")-1), true)) && 
               ((Token+1)->type == JSMN_STRING)) 
{
            ItemExists->TestString = true;
    ++Token;
    TokenLength = Token->end - Token->start;
    s32 Length = MINIMUM(TokenLength, (50-1));
    strncpy(ObjectOut->TestString, &Json[Token->start], Length);
    ObjectOut->TestString[Length] = 0;
}

            if((abs_AreStringsEqual(&Json[Token->start], TokenLength, "MyColour",(ArrayCount("MyColour")-1), true)) && 
               (((Token+1)->type == JSMN_STRING) || ((Token+1)->type == JSMN_OBJECT))) 
{
            ItemExists->MyColour = true;
Token = JsonToObject(VolatileMemory, Json, JsonLength, ++Token,  &ObjectOut->MyColour,0);
}

            if((abs_AreStringsEqual(&Json[Token->start], TokenLength, "isValue",(ArrayCount("isValue")-1), true)) && 
               ((Token+1)->type == JSMN_PRIMITIVE)) 
{
            ItemExists->isValue = true;
    ++Token;
     (ObjectOut->isValue) = (strncmp(&Json[Token->start],"true",4) == 0);
}


}
}
if(ItemsExistOut)
{
    *ItemsExistOut = *ItemExists;
}
return Token;
}

u32
JsonArrayToObjectArray(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, my_json_test **ObjectArray, my_json_test_existlist **ObjectArrayExists)
{
   u32 NumberOfObjects = 0;
            
    jsmntok_t *TokenArray = 0;
    s32 NumTokensParsed = ParseJson(VolatileMemory, Json, JsonLength, &TokenArray);
    
    if(TokenArray)
    {
        u32 TokenIndex = 0;
        jsmntok_t *Token = &TokenArray[TokenIndex++];
        if(Token->type == JSMN_OBJECT)
        {
            // NOTE(Amos): Next token will be a string; not checking label strings yet.
            ++TokenIndex;
            Token = &TokenArray[TokenIndex++];
        }
        
        if(Token->type == JSMN_ARRAY)
        {
            NumberOfObjects= Token->size;
            ++Token;
        }
        else if(Token->type == JSMN_OBJECT)
        {
            NumberOfObjects = 1;
        }
        
        if (!(*ObjectArray))
        {
            *ObjectArray = abm_PushArray(VolatileMemory, NumberOfObjects, my_json_test);
        }
        if (!(*ObjectArrayExists))
        {
            *ObjectArrayExists = abm_PushArray(VolatileMemory, NumberOfObjects, my_json_test_existlist);
        }
        
        for(u32 Index = 0; Index < NumberOfObjects; ++Index)
        {
            Token = JsonToObject(VolatileMemory, Json, JsonLength, Token, &(*ObjectArray)[Index],&(*ObjectArrayExists)[Index]);
            ++Token;
        }
    }
    return NumberOfObjects;
}
#endif



#endif // GENERATED_TEST_SRC
