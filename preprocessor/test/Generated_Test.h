/**   GENERATED    **/
/** 
    Code Generator Version: 1.0

    This file was autogenerated. Do not edit directly, your changes will get over-written. 
    This is a single file include. To include the source, add 

#define GENERATED_TEST_SRC

    before including this this file.

    If you are using JSON parsing, add 

#define GEN_JSMN_HEADER

    Ensure the jsmn.h header is in your include directory.
**/

#ifndef TAG
#define TAG(...)
#endif

#ifndef STATEMACHINE
#define STATEMACHINE(...)
#endif
#include <stdlib.h>
#include "ab_memory.h"
#include "ab_string.h"
#include "stb_sprintf.h"
#ifdef GEN_JSMN_HEADER
#include "ab_json.h"
#endif // GEN_JSMN_HEADER


#if !defined(_GENERATED_HEADER_)
#define _GENERATED_HEADER_
template<typename T>
auto StringToEnum(const char *String) -> T;

template<typename T>
auto StringToEnum(abs_stringptr String) -> T;


#endif

#if !defined(_AB_GENERATED_HEADER_GENERATED_TEST_)
#define _AB_GENERATED_HEADER_GENERATED_TEST_

/****  StateMachine: TEST_STATEMACHINE ****/
struct test_type;
enum class test_cmd;
/***** Queue: test_cmd ****/
// Creating a circular queue of 10 elements.
struct test_cmd_queue
{
    test_cmd Items[10];
    s32 Front;
    s32 Rear;
};

inline void InitializeQueue(test_cmd_queue *Queue);
inline b8 isQueueEmpty(test_cmd_queue *Queue);
inline b8 isQueueFull(test_cmd_queue *Queue);
b8 EnqueueCommand(test_cmd_queue *Queue, test_cmd Cmd);
test_cmd DequeueCommand(test_cmd_queue *Queue);
/***********/

#define TEST_STATEMACHINE(name) void name(test_type *State, test_cmd Cmd, int Int, char const *String)
typedef TEST_STATEMACHINE(test_statemachine);

inline b8 GoToState(test_type *State, test_statemachine *NewState);
char const *GetStateName(test_statemachine *StateName);
b8 EnqueueCommand(test_type *State, test_cmd Cmd);
test_cmd DequeueCommand(test_type *State);

TEST_STATEMACHINE(Idle);
TEST_STATEMACHINE(Running);

/*********/

/****** Enum test_cmd Header *****/
enum class test_cmd;
const u32 test_cmd_Count = 6;
template<>
auto StringToEnum<test_cmd>(const char *String) -> test_cmd;
template<>
auto StringToEnum<test_cmd>(abs_stringptr String) -> test_cmd;
constexpr abs_stringptr EnumToString(test_cmd EnumToken);
constexpr char const* EnumToCString(test_cmd EnumToken);

/****** Enum Colours Header *****/
enum class Colours;
const u32 Colours_Count = 3;
#ifdef GEN_JSMN_HEADER
jsmntok_t *JsonToObject(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, jsmntok_t *TokenArray, Colours *ObjectOut, u32 Unused);
u32
PushJson(char *Json, u32 MaxLength, char const *Tag, Colours Type, u32 JsonFlags);
#endif

template<>
auto StringToEnum<Colours>(const char *String) -> Colours;
template<>
auto StringToEnum<Colours>(abs_stringptr String) -> Colours;
constexpr abs_stringptr EnumToString(Colours EnumToken);
constexpr char const* EnumToCString(Colours EnumToken);
const char *EnumToLabel_Object(Colours EnumToken);
//const char * Colours_LabelObject[Colours_Count];

/****** Struct my_json_test Header *****/
struct my_json_test;
#ifdef GEN_JSMN_HEADER
u32 PushJson(char *Json, u32 MaxLength, char const *Tag, const my_json_test &Value, u32 JsonFlags);
struct my_json_test_existlist;
jsmntok_t *JsonToObject(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, jsmntok_t *TokenArray, my_json_test *ObjectOut, my_json_test_existlist *ItemsExistOut);
u32
JsonArrayToObjectArray(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, my_json_test **ObjectArray, my_json_test_existlist **ObjectArrayExist);
#endif

struct my_json_test_existlist
{
   b8 TestUnsigned;
   b8 TestString;
   b8 MyColour;
   b8 isValue;
};


#endif // _AB_GENERATED_HEADER_GENERATED_TEST_

#if defined(GENERATED_TEST_SRC)
#undef GENERATED_TEST_SRC

#if !defined(_GENERATED_SRC_)
#define _GENERATED_SRC_

#define STB_SPRINTF_IMPLEMENTATION
#include "stb_sprintf.h"
#undef STB_SPRINTF_IMPLEMENTATION


#endif
/****** Queue: test_cmd ****/
inline void
InitializeQueue(test_cmd_queue *Queue)
{
  Queue->Front = Queue->Rear = -1;
}

inline b8
isQueueEmpty(test_cmd_queue *Queue)
{
  b8 Result = (Queue->Front == -1);
  return Result;
}

inline b8 
isQueueFull(test_cmd_queue *Queue)
{
  b8 Result = (Queue->Front == Queue->Rear + 1) ||
  (Queue->Front == 0 && Queue->Rear == (10-1));

  return Result;
}

b8
Enqueue(test_cmd_queue *Queue, test_cmd Cmd)
{
  b8 Result = false;
  if(!isQueueFull(Queue))
  {
    if(Queue->Front == -1)
    {
      Queue->Front = 0;
    }
    Queue->Rear = (Queue->Rear + 1) % 10;
    Queue->Items[Queue->Rear] = Cmd;

    Result = true;
  }
  return Result;    
}

test_cmd
Dequeue(test_cmd_queue *Queue)
{
test_cmd Result = (test_cmd)0;
if(!isQueueEmpty(Queue))
{
Result = Queue->Items[Queue->Front];
if(Queue->Front == Queue->Rear)
{
Queue->Front = Queue->Rear = -1;
}
else 
{
Queue->Front = (Queue->Front + 1) % 10;
}
}

return Result;
}

/***********/

/**** StateMachine: TEST_STATEMACHINE **/
// Function Definitions
inline b8
GoToState(test_type *State, test_statemachine *NewState)
{
    b8 isChanged = false;
    if(NewState && State)
    {
        State->CurrentState = NewState;
        State->isNewState = true;
    }

    return isChanged;
}

char const*
GetStateName(test_statemachine *StateName)
{
if(StateName == Idle) {return "Idle";}
if(StateName == Running) {return "Running";}
return "Unknown";
}

b8
EnqueueCommand(test_type *State, test_cmd Cmd)
{
return Enqueue(&State->CommandQueue, Cmd);
}

test_cmd
DequeueCommand(test_type *State)
{
return Dequeue(&State->CommandQueue);
}


/*********/

/****** Enum test_cmd Functions *****/
constexpr abs_stringptr test_cmd_Strings[test_cmd_Count] = 
{
   {"NOP", 3},
   {"Command1", 8},
   {"Command2", 8},
   {"Command3", 8},
   {"Command4", 8},
   {"Last", 4},
};

template<>
auto StringToEnum<test_cmd>(const char *String) -> test_cmd
{
    u32 StringIndex = abs_FindInList(String, test_cmd_Count, test_cmd_Strings, true);
    test_cmd Result = test_cmd::NOP;
    if(StringIndex < test_cmd_Count)
    {
        Result = static_cast<test_cmd>(StringIndex);
    }
    return Result;
}
template<>
auto StringToEnum<test_cmd>(abs_stringptr String) -> test_cmd
{
    u32 StringIndex = abs_FindInList(String, test_cmd_Count, test_cmd_Strings, true);
    test_cmd Result = test_cmd::NOP;
    if(StringIndex < test_cmd_Count)
    {
        Result = static_cast<test_cmd>(StringIndex);
    }
    return Result;
}
constexpr const char *
EnumToCString(test_cmd EnumToken)
{
    return test_cmd_Strings[int(EnumToken)].String;
}

constexpr abs_stringptr
EnumToString(test_cmd EnumToken)
{
    return test_cmd_Strings[int(EnumToken)];
}


/****** Enum Colours Functions *****/
#ifdef GEN_JSMN_HEADER
u32
PushJson(char *Json, u32 MaxLength, char const *Tag, Colours Type, u32 JsonFlags = 0)
{
    u32 Length = 0;
    b8 isLast = (JsonFlags & JSON_IsLastInList);
    Length += stbsp_snprintf(Json, MaxLength, "\"%s\":\"%s\"", Tag, EnumToCString(Type));
    if(!isLast) { Json[Length++] = ','; }
    return Length;
}

jsmntok_t *JsonToObject(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, jsmntok_t *TokenArray, Colours *ObjectOut, u32 Unused)
{
    Colours Result = static_cast<Colours>(0);
    s32 NumTokensUsed = 0;
    
    s32 TotalTokens = ParseJson(VolatileMemory, Json, JsonLength, &TokenArray);
    if(TokenArray)
    {
        s32 Index = 0;
        if((TokenArray[Index].type == JSMN_OBJECT) &&
           (TotalTokens > 1))
        {
            ++Index;
        }
        if(TokenArray[Index].type == JSMN_STRING)
        {
            s32 TokenLength = (TokenArray[Index].end - TokenArray[Index].start);
            abs_stringptr EnumString = {&Json[TokenArray[Index].start], TokenLength};
            Result = StringToEnum<Colours>(EnumString);
            NumTokensUsed = Index;
        }
        else 
        {
            NumTokensUsed = Index;
        }
    }
    *ObjectOut = Result;
    return TokenArray + NumTokensUsed;
}

#endif

constexpr abs_stringptr Colours_Strings[Colours_Count] = 
{
   {"Red", 3},
   {"Green", 5},
   {"Blue", 4},
};

template<>
auto StringToEnum<Colours>(const char *String) -> Colours
{
    u32 StringIndex = abs_FindInList(String, Colours_Count, Colours_Strings, true);
    Colours Result = Colours::Red;
    if(StringIndex < Colours_Count)
    {
        Result = static_cast<Colours>(StringIndex);
    }
    return Result;
}
template<>
auto StringToEnum<Colours>(abs_stringptr String) -> Colours
{
    u32 StringIndex = abs_FindInList(String, Colours_Count, Colours_Strings, true);
    Colours Result = Colours::Red;
    if(StringIndex < Colours_Count)
    {
        Result = static_cast<Colours>(StringIndex);
    }
    return Result;
}
constexpr const char *
EnumToCString(Colours EnumToken)
{
    return Colours_Strings[int(EnumToken)].String;
}

constexpr abs_stringptr
EnumToString(Colours EnumToken)
{
    return Colours_Strings[int(EnumToken)];
}

const char * Colours_LabelObject[Colours_Count] = 
{
    "Apple",
    "Brocoli",
    "Blueberry",
};

const char *
EnumToLabel_Object(Colours EnumToken)
{
    return Colours_LabelObject[int(EnumToken)];
}


/****** Struct my_json_test Functions *****/
#ifdef GEN_JSMN_HEADER
u32 PushJson(char *Json, u32 MaxLength, char const*Tag, const my_json_test &Value, u32 JsonFlags = 0)
{
    u32 Length = 0;
    b8 isLast = (JsonFlags & JSON_IsLastInList);
    if(JsonFlags & JSON_BaseObject)
    {
        Json[Length++] = '{';
    }
    if(!(JsonFlags & JSON_DontUseTag))
    {
          Length += stbsp_snprintf(&Json[Length], MaxLength, "\"%s\":", Tag);
    }
    Length += StartGroup(&Json[Length], (MaxLength - Length));
Length += stbsp_snprintf(&Json[Length], (MaxLength - Length), "\"TestUnsigned\":%u,",  (Value.TestUnsigned));
{
size_t StringLen = abs_StringLength(Value.TestString, 50);
Length += stbsp_snprintf(&Json[Length], (MaxLength - Length), "\"TestString\":\"%.*s\",", (s32)StringLen, Value.TestString);
}
Length += PushJson(&Json[Length], (MaxLength - Length), "MyColour",  (Value.MyColour), JSON_Null);
Length += stbsp_snprintf(&Json[Length], (MaxLength - Length), "\"isValue\":%s ", ( (Value.isValue) ? "true" : "false"));
    Length += EndGroup(&Json[Length], (MaxLength - Length), isLast);
    if(JsonFlags & JSON_BaseObject)
    {
        Json[Length++] = '}';
    }
    return Length;
}

jsmntok_t *JsonToObject(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, jsmntok_t *TokenArray, my_json_test *ObjectOut, my_json_test_existlist *ItemsExistOut)
{
    my_json_test_existlist* ItemExists = abm_PushStruct(VolatileMemory, my_json_test_existlist);
    s32 NumTokensProcessed =  ParseJson(VolatileMemory, Json, JsonLength, &TokenArray);
    jsmntok_t *Token = TokenArray;
    if(Token)
    {
        s32 NumTokensToProcess = Token->size;
        s32 ObjectEndPosition = Token->end;
        for(s32 Index = 0; Index < NumTokensToProcess; ++Index)
        {
            ++Token;
            s32 TokenLength = Token->end - Token->start;
            
            if((abs_AreStringsEqual(&Json[Token->start], TokenLength, "TestUnsigned",(ArrayCount("TestUnsigned")-1), true)) && 
               ((Token+1)->type == JSMN_PRIMITIVE)) 
{
            ItemExists->TestUnsigned = true;
    ++Token;
     (ObjectOut->TestUnsigned) = (u8)atoi(&Json[Token->start]);
}

            if((abs_AreStringsEqual(&Json[Token->start], TokenLength, "TestString",(ArrayCount("TestString")-1), true)) && 
               ((Token+1)->type == JSMN_STRING)) 
{
            ItemExists->TestString = true;
    ++Token;
    TokenLength = Token->end - Token->start;
    s32 Length = MINIMUM(TokenLength, (50-1));
    strncpy(ObjectOut->TestString, &Json[Token->start], Length);
    ObjectOut->TestString[Length] = 0;
}

            if((abs_AreStringsEqual(&Json[Token->start], TokenLength, "MyColour",(ArrayCount("MyColour")-1), true)) && 
               (((Token+1)->type == JSMN_STRING) || ((Token+1)->type == JSMN_OBJECT))) 
{
            ItemExists->MyColour = true;
Token = JsonToObject(VolatileMemory, Json, JsonLength, ++Token,  &ObjectOut->MyColour,0);
}

            if((abs_AreStringsEqual(&Json[Token->start], TokenLength, "isValue",(ArrayCount("isValue")-1), true)) && 
               ((Token+1)->type == JSMN_PRIMITIVE)) 
{
            ItemExists->isValue = true;
    ++Token;
     (ObjectOut->isValue) = (strncmp(&Json[Token->start],"true",4) == 0);
}


}
}
if(ItemsExistOut)
{
    *ItemsExistOut = *ItemExists;
}
return Token;
}

u32
JsonArrayToObjectArray(memory_arena *VolatileMemory, char const *Json, size_t JsonLength, my_json_test **ObjectArray, my_json_test_existlist **ObjectArrayExists)
{
   u32 NumberOfObjects = 0;
            
    jsmntok_t *TokenArray = 0;
    s32 NumTokensParsed = ParseJson(VolatileMemory, Json, JsonLength, &TokenArray);
    
    if(TokenArray)
    {
        u32 TokenIndex = 0;
        jsmntok_t *Token = &TokenArray[TokenIndex++];
        if(Token->type == JSMN_OBJECT)
        {
            // NOTE(Amos): Next token will be a string; not checking label strings yet.
            ++TokenIndex;
            Token = &TokenArray[TokenIndex++];
        }
        
        if(Token->type == JSMN_ARRAY)
        {
            NumberOfObjects= Token->size;
            ++Token;
        }
        else if(Token->type == JSMN_OBJECT)
        {
            NumberOfObjects = 1;
        }
        
        if (!(*ObjectArray))
        {
            *ObjectArray = abm_PushArray(VolatileMemory, NumberOfObjects, my_json_test);
        }
        if (!(*ObjectArrayExists))
        {
            *ObjectArrayExists = abm_PushArray(VolatileMemory, NumberOfObjects, my_json_test_existlist);
        }
        
        for(u32 Index = 0; Index < NumberOfObjects; ++Index)
        {
            Token = JsonToObject(VolatileMemory, Json, JsonLength, Token, &(*ObjectArray)[Index],&(*ObjectArrayExists)[Index]);
            ++Token;
        }
    }
    return NumberOfObjects;
}
#endif



#endif // GENERATED_TEST_SRC
